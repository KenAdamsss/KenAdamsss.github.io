<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop</title>
    <url>/2019/05/04/Hadoop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、从Hadoop框架讨论大数据生态"><a href="#一、从Hadoop框架讨论大数据生态" class="headerlink" title="一、从Hadoop框架讨论大数据生态"></a>一、从Hadoop框架讨论大数据生态</h3><h4 id="1-1-Hadoop是什么"><a href="#1-1-Hadoop是什么" class="headerlink" title="1.1 Hadoop是什么"></a>1.1 Hadoop是什么</h4><ol>
<li>Hadoop 是一个 Apache 基金会所开发的分布式系统基础架构</li>
<li>主要解决，海量数据的存储（HDFS） 和 海量数据的分析计算 （MapReduce）问题</li>
<li>广义上说，Hadoop 通常是指一个更广泛的概念 - Hadoop 生态圈</li>
</ol>
<a id="more"></a>

<h4 id="1-2-Hadoop-发展历史"><a href="#1-2-Hadoop-发展历史" class="headerlink" title="1.2 Hadoop 发展历史"></a>1.2 Hadoop 发展历史</h4><h4 id="1-3-Hadoop-三大发行版本"><a href="#1-3-Hadoop-三大发行版本" class="headerlink" title="1.3 Hadoop 三大发行版本"></a>1.3 Hadoop 三大发行版本</h4><p>Apache、Cloudera、Hortonworks</p>
<h4 id="1-4-Hadoop-的优势"><a href="#1-4-Hadoop-的优势" class="headerlink" title="1.4 Hadoop 的优势"></a>1.4 Hadoop 的优势</h4><ol>
<li><strong>高可靠性</strong><br>因为Hadoop假设计算元素和存储会出现故障，因为它维护多个工作数据副本，在出现故障时可以对失败的节点重新分布处理</li>
<li><strong>高扩展性</strong><br>在集群分配任务数据，可方便的扩展数以千计的节点</li>
<li><strong>高效性</strong><br>在 MapReduce 的思想下，Hadoop 是并行工作的，以加快任务处理速度</li>
<li><strong>高容错性</strong><br>自动保存多份副本数据，并且能够自动将失败的任务重新分配</li>
</ol>
<h4 id="1-5-Hadoop-组成"><a href="#1-5-Hadoop-组成" class="headerlink" title="1.5 Hadoop 组成"></a>1.5 Hadoop 组成</h4><p><strong>概述</strong></p>
<ol>
<li><strong>Hadoop HDFS</strong> : 一个高可靠、高吞吐量的<strong>分布式文件系统</strong></li>
<li><strong>Hadoop MapReduce</strong> : 一个分布式的<strong>离线并行计算</strong>框架</li>
<li><strong>Hadoop YARN</strong> : 作业调度与集群资源管理的框架</li>
<li><strong>Hadoop Common</strong> : 支持其他模块的工具模块</li>
</ol>
<h5 id="1-5-1-HDFS-架构概述"><a href="#1-5-1-HDFS-架构概述" class="headerlink" title="1.5.1  HDFS 架构概述"></a>1.5.1  HDFS 架构概述</h5><ol>
<li><strong>NameNode (nn)</strong> : 存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的 DataNode 等</li>
<li><strong>DataNode （dn）</strong>` : 在本地文件系统存储文件块数据，以及块数据的校验和</li>
<li><code>SecondaryNameNode (2nn)</code> : 用来监控 HDFS 状态的辅助后台程序，每隔一段时间获取 HDFS 元数据的快照。</li>
</ol>
<h5 id="1-5-2-YARN-架构概述"><a href="#1-5-2-YARN-架构概述" class="headerlink" title="1.5.2 YARN 架构概述"></a>1.5.2 YARN 架构概述</h5><ol>
<li><strong>ResourceManager (rm)</strong> :<br>处理客户端请求、启动/监控 ApplicationMaster、监控 NodeManager 、<strong>资源</strong>分配与调度</li>
<li><strong>NodeManager (nm)</strong> :<br><em>单个节点上的资源管理</em>、处理来自 ResourceManager 的命令、处理来自 ApplicationMaster 的命令</li>
<li><strong>ApplicationMaster</strong> :<br>数据切分、为应用程序申请资源，并分配给内部任务、任务监控与容错</li>
<li><strong>Container :</strong><br>对任务运行环境的抽象，封装了 CPU 、内存等多位资源以及环境变量、启动命令等任务运行相关的信息</li>
</ol>
<h5 id="1-5-3-MapReduce-架构概述"><a href="#1-5-3-MapReduce-架构概述" class="headerlink" title="1.5.3 MapReduce 架构概述"></a>1.5.3 MapReduce 架构概述</h5><p>MapReduce 将计算过程分成两个阶段 ： Map 和 Reduce</p>
<ol>
<li>Map 阶段并行处理输入数据</li>
<li>Reduce 阶段对 Map 结果进行汇总</li>
</ol>
<h4 id="1-6-大数据技术生态体系"><a href="#1-6-大数据技术生态体系" class="headerlink" title="1.6 大数据技术生态体系"></a>1.6 大数据技术生态体系</h4><h4 id="1-7-推荐系统框架图"><a href="#1-7-推荐系统框架图" class="headerlink" title="1.7 推荐系统框架图"></a>1.7 推荐系统框架图</h4><h3 id="二、Hadoop运行环境搭建"><a href="#二、Hadoop运行环境搭建" class="headerlink" title="二、Hadoop运行环境搭建"></a>二、Hadoop运行环境搭建</h3><h4 id="2-1-虚拟机网络模式设置为-NAT"><a href="#2-1-虚拟机网络模式设置为-NAT" class="headerlink" title="2.1 虚拟机网络模式设置为 NAT"></a>2.1 虚拟机网络模式设置为 NAT</h4><h4 id="2-1-克隆虚拟机"><a href="#2-1-克隆虚拟机" class="headerlink" title="2.1 克隆虚拟机"></a>2.1 克隆虚拟机</h4><h4 id="2-3-修改为静态-IP"><a href="#2-3-修改为静态-IP" class="headerlink" title="2.3 修改为静态 IP"></a>2.3 修改为静态 IP</h4><h4 id="2-4-修改主机名"><a href="#2-4-修改主机名" class="headerlink" title="2.4 修改主机名"></a>2.4 修改主机名</h4><h4 id="2-5-关闭防火墙"><a href="#2-5-关闭防火墙" class="headerlink" title="2.5 关闭防火墙"></a>2.5 关闭防火墙</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改 克隆来的机器的 eth0</span></span><br><span class="line">vi /etc/udev/rules.d/70-persistent-net.rules </span><br><span class="line">	删除eth0 升级eht1为eth0 </span><br><span class="line">	复制物理ip地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改</span> </span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0 </span><br><span class="line">	粘贴复制的物理ip地址</span><br><span class="line">	修改 IPADDR</span><br><span class="line">	</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看主机名</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名</span></span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 hosts 文件</span></span><br><span class="line">vi /etc/hosts</span><br><span class="line">	192.168.188.100 hadoop100</span><br><span class="line">	192.168.188.101 hadoop101</span><br><span class="line">	192.168.188.102 hadoop102</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line">sync </span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙</span></span><br><span class="line">chkconfig iptables --list</span><br></pre></td></tr></table></figure>


<h4 id="2-6-在-opt-目录下创建文件"><a href="#2-6-在-opt-目录下创建文件" class="headerlink" title="2.6 在 opt 目录下创建文件"></a>2.6 在 opt 目录下创建文件</h4><p>使用 <code>atguigu</code> 用户在 /opt 目录下创建 module  software 目录</p>
<p>module ： 安装目录</p>
<p>software  ：接收从window 传输过来的安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改 atguigu 用户权限</span></span><br><span class="line">vi /etc/sudoers</span><br><span class="line"><span class="meta">#</span><span class="bash"> atguigu 使用 sudo 创建 目录</span></span><br><span class="line">sudo mkdir module</span><br><span class="line"></span><br><span class="line">sudo mkdir module</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改用户所有者 和 用户组</span></span><br><span class="line">sudo chown atguigu:atguigu module/ software/</span><br></pre></td></tr></table></figure>


<h4 id="2-7-安装-jdk"><a href="#2-7-安装-jdk" class="headerlink" title="2.7 安装 jdk"></a>2.7 安装 jdk</h4><ol>
<li><p>卸载现有的 jdk</p>
</li>
<li><p>用 filezilla 工具将 jdk 、Hadoop-2.7.2.tar.gz 导入到 opt 目录下面的 software 文件夹下</p>
</li>
<li><p>在 linux 系统下的 opt 目录中查看软件包是否导入成功</p>
</li>
<li><p>解压 jdk 到 /opt/module 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-7u79-linux-x64.gz -C /opt/module/</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>配置 jdk 环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br><span class="line"></span><br><span class="line">Shift + G</span><br><span class="line">o</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.7.0_79</span><br><span class="line">exprot PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>测试 jdk 安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">或</span><br><span class="line">rpm -qa |grep java</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="2-8-安装-Hadoop"><a href="#2-8-安装-Hadoop" class="headerlink" title="2.8 安装 Hadoop"></a>2.8 安装 Hadoop</h4><ol>
<li><p>进入到 Hadoop 安装包路径下：</p>
</li>
<li><p>解压安装文件到 /opt/moudle 下面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>查看解压是否成功</p>
</li>
<li><p>配置 hadoop 中的 hadoop-env.sh</p>
<ol>
<li><p>Linux 系统中获取 jdk 的安装路径</p>
</li>
<li><p>修改 hadoop-env.sh 文件中 JAVA_HOME 路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/module/hadoop-2.7.2/etc/hadoop</span><br><span class="line"></span><br><span class="line">sudo vi hadoop-env.sh</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.7.0_79</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<ol start="5">
<li><p>将Hadoop添加到环境变量</p>
<ol>
<li><p>获取 Hadoop 安装路径</p>
</li>
<li><p>打开 /etc/profile 文件</p>
</li>
<li><p>保存后退出</p>
</li>
<li><p>让修改后的文件生效</p>
</li>
<li><p>重启 （如果Hadoop命令不能用再重启）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#HADOOP_HOME</span></span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<h3 id="三、Hadoop运行模式"><a href="#三、Hadoop运行模式" class="headerlink" title="三、Hadoop运行模式"></a>三、Hadoop运行模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>官方网址</li>
<li>Hadoop 运行模式<ol>
<li>本地模式（默认模式）：不需要启动单独进程，直接可以运行，测试和开发时使用</li>
<li>伪分布式模式 ：等同于完全分布式，只有一个节点</li>
<li>完全分布式模式： 多个节点一起运行</li>
</ol>
</li>
</ol>
<h4 id="3-1-本地文件运行-Hadoop-案例"><a href="#3-1-本地文件运行-Hadoop-案例" class="headerlink" title="3.1 本地文件运行 Hadoop 案例"></a>3.1 本地文件运行 Hadoop 案例</h4><h5 id="3-1-1-官方-grep-案例"><a href="#3-1-1-官方-grep-案例" class="headerlink" title="3.1.1 官方 grep 案例"></a>3.1.1 官方 grep 案例</h5><ol>
<li><p>创建在 hadoop-2.7.2 文件下面 创建一个 input 文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir input</span><br></pre></td></tr></table></figure></li>
<li><p>将 hadoop 的 xml 配置文件复制到input</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp etc/hadoop/*.xml input/</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>执行share目录下的mapreduce 程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output &#x27;dfs[a-z]+&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据结果</p>
</li>
</ol>
<h5 id="3-1-2-官方-wordcount-案例"><a href="#3-1-2-官方-wordcount-案例" class="headerlink" title="3.1.2 官方 wordcount 案例"></a>3.1.2 官方 wordcount 案例</h5><ol>
<li><p>创建在 hadoop-2.7.2 文件下面创建一个wcinput 文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir wcinput</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>在 wcinput 文件下创建一个 wc.input 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 随便一个文本</span></span><br><span class="line">touch wc.input</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>编辑 wc.input 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi wc.input</span><br><span class="line"><span class="meta">#</span><span class="bash"> 随便写点东西</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>回到 hadoop 目录 /opt/module/hadoop-2.7.2</p>
</li>
<li><p>执行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li>查看结果</li>
</ol>
<h4 id="3-2-伪分布式运行-Hadoop-案例"><a href="#3-2-伪分布式运行-Hadoop-案例" class="headerlink" title="3.2 伪分布式运行 Hadoop 案例"></a>3.2 伪分布式运行 Hadoop 案例</h4><h5 id="3-2-1-HDFS-上运行-MapReduce-程序"><a href="#3-2-1-HDFS-上运行-MapReduce-程序" class="headerlink" title="3.2.1 HDFS 上运行 MapReduce 程序"></a>3.2.1 HDFS 上运行 MapReduce 程序</h5><ol>
<li><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><ol>
<li>准备一台客户机</li>
<li>安装JDK</li>
<li>配置环境变量</li>
<li>安装Hadoop</li>
<li>配置环境变量</li>
<li>配置集群</li>
<li>启动、测试集群增、删、查</li>
<li>在 HDFS上 执行 wordcount 案例</li>
</ol>
</li>
<li><h6 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h6><ol>
<li><p>配置集群<br>a. 配置 ： hadoop-env.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux 系统获取 jdk 的安装路径</span><br><span class="line">      </span><br><span class="line">修改 JAVA_HOME 路径</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>b. 配置 ： core-site.xml</p>
</li>
</ol>
</li>
</ol>
<pre><code>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定 HDFS 中 NameNode 的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop101:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-2.7.2/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
  c. 配置 :     hdfs-site.xml

  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定 HDFS 副本的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre>
<ol start="2">
<li><p>启动集群</p>
<p>a. 格式化 namenode (第一次启动时格式化，以后就不要总格式化)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>b. 启动 namenode</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br></pre></td></tr></table></figure>
<p>c. 启动 datanode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop-deamon.sh start datanode</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看java进程</span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure></li>
<li><p>查看集群<br>a. 查看是否启动成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>
<p>b. 查看产生的 log 日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> logs 文件夹下</span></span><br><span class="line">.log 文件</span><br></pre></td></tr></table></figure>
<p>c. web端查看 HDFS 文件系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.188.101:50070</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>操作集群<br>a. 在 hdfs 文件夹系统上创建一个 input 文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`hadoop fs` (等价) `bin/hdfs dfs`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 input 目录</span></span><br><span class="line">hadoop fs -mkdir -p /user/atguigu/input</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归列出目录</span></span><br><span class="line">[atguigu@hadoop101 logs]$ hadoop fs -ls -R /</span><br><span class="line">drwxr-xr-x   - atguigu supergroup          0 2019-05-12 13:19 /user</span><br><span class="line">drwxr-xr-x   - atguigu supergroup          0 2019-05-12 13:19 /user/atguigu</span><br><span class="line">drwxr-xr-x   - atguigu supergroup          0 2019-05-12 13:19 /user/atguigu/input</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令同上,递归列出目录</span></span><br><span class="line">hadoop fs -lsr</span><br></pre></td></tr></table></figure>
<p>b. 将测试文件内容上传到 文件系统上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -put wcinput/wc.input /user/atguigu/input</span><br></pre></td></tr></table></figure>
<p>c. 查看上传的文件是否正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -lsr</span><br></pre></td></tr></table></figure>
<p>d. 在 hdfs 上运行 mapreduce  程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input/ /user/atguigu/output</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">hadoop fs -cat /user/atguigu/output/p*</span><br></pre></td></tr></table></figure>
<p>e. 查看输出结果</p>
<p>f. 将测试文件内容下载到本地</p>
<p>g. 删除输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -rmr /user/atguigu/output</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="3-2-2-YARN-上运行-MapReduce-程序"><a href="#3-2-2-YARN-上运行-MapReduce-程序" class="headerlink" title="3.2.2 YARN 上运行 MapReduce 程序"></a>3.2.2 YARN 上运行 MapReduce 程序</h5><h5 id="3-2-3-修改本地临时文件存储目录"><a href="#3-2-3-修改本地临时文件存储目录" class="headerlink" title="3.2.3 修改本地临时文件存储目录"></a>3.2.3 修改本地临时文件存储目录</h5><h5 id="3-2-4-Hadoop配置文件说明"><a href="#3-2-4-Hadoop配置文件说明" class="headerlink" title="3.2.4 Hadoop配置文件说明"></a>3.2.4 Hadoop配置文件说明</h5><h4 id="3-3-完全分布式部署-Hadoop"><a href="#3-3-完全分布式部署-Hadoop" class="headerlink" title="3.3 完全分布式部署 Hadoop"></a>3.3 完全分布式部署 Hadoop</h4><h3 id="四、Hadoop编译源码"><a href="#四、Hadoop编译源码" class="headerlink" title="四、Hadoop编译源码"></a>四、Hadoop编译源码</h3>]]></content>
      <categories>
        <category>Big Data</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit单元测试</title>
    <url>/2019/08/17/Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><h5 id="测试分类："><a href="#测试分类：" class="headerlink" title="测试分类："></a>测试分类：</h5><ol>
<li><strong>黑盒测试</strong> ： 不需要写代码。给输入值，看程序是否能够输出期望的值。</li>
<li><strong>白盒测试</strong> ： 需要写代码；关注程序具体的执行流程。</li>
</ol>
<a id="more"></a>

<h4 id="Junit使用-：白盒测试"><a href="#Junit使用-：白盒测试" class="headerlink" title="Junit使用 ：白盒测试"></a>Junit使用 ：白盒测试</h4><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li><strong>定义一个测试类（测试用例）</strong><ul>
<li>建议：<ul>
<li><strong>测试类名</strong>：被测试的类名Test </li>
<li><strong>包名</strong>：xxx.xxx.xx.test</li>
</ul>
</li>
</ul>
</li>
<li><strong>定义测试方法：可以独立运行</strong><ul>
<li>建议：<ul>
<li>方法名：test测试的方法名</li>
<li>返回值：<code>void</code></li>
<li>参数列表：空参</li>
</ul>
</li>
</ul>
</li>
<li><strong>给方法加<code>@Test</code></strong></li>
<li><strong>导入<code>Junit</code>依赖环境</strong></li>
</ol>
<h6 id="判定结果"><a href="#判定结果" class="headerlink" title="判定结果"></a>判定结果</h6><ul>
<li>红色：失败</li>
<li>黑色：成功</li>
<li>一般我们会用断言来操作处理结果<ul>
<li><code>Assert.assertEquals(期望结果,运算结果)</code></li>
</ul>
</li>
</ul>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><ul>
<li><p><code>@Before</code><br>修饰的方法会在<strong>测试方法之前</strong>被自动执行，一般用于加载资源</p>
</li>
<li><p><code>@After</code></p>
<p>修饰的方法会在<strong>测试方法执行之后</strong>自动被执行，一般用于关闭资源</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进阶（二）</title>
    <url>/2019/01/17/Linux%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="7-7-磁盘分区类"><a href="#7-7-磁盘分区类" class="headerlink" title="7.7 磁盘分区类"></a>7.7 磁盘分区类</h4><h5 id="7-7-1-fdisk查看分区"><a href="#7-7-1-fdisk查看分区" class="headerlink" title="7.7.1 fdisk查看分区"></a>7.7.1 <code>fdisk</code>查看分区</h5><p>​    基本语法：<code>fdisk -l</code></p>
<h5 id="7-7-2-查看硬盘"><a href="#7-7-2-查看硬盘" class="headerlink" title="7.7.2 查看硬盘"></a>7.7.2 查看硬盘</h5><p>​    <code>df -h</code></p>
<h5 id="7-7-3-mount-umount-挂载-卸载"><a href="#7-7-3-mount-umount-挂载-卸载" class="headerlink" title="7.7.3 mount / umount 挂载 /卸载"></a>7.7.3 <code>mount / umount</code> 挂载 /卸载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">挂载：mount -t  iso9660 -o rw /dev/cdrom /mnt/cdrom/</span><br><span class="line">卸载：umnout /mnt/cdrom</span><br></pre></td></tr></table></figure>


<h4 id="7-8-搜索查找类"><a href="#7-8-搜索查找类" class="headerlink" title="7.8 搜索查找类"></a>7.8 搜索查找类</h4><h5 id="7-8-1-find-查找文件或目录"><a href="#7-8-1-find-查找文件或目录" class="headerlink" title="7.8.1 find 查找文件或目录"></a>7.8.1 find 查找文件或目录</h5><p>​    基本语法： <code>find [搜索范围] [匹配条件]</code></p>
<p>​    案例：</p>
<p>​        (1) 按文件名，根据名称查找 /目录下 的 <code>filename.txt</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home/atguigu/ -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>
<p>​        (2) 按拥有者，查找 /opt 目录下，用户名为 -user 的文件</p>
<p>​    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv -t bb shaolinsi # 移动 shaolinsi 到 bb 目录内</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find tlbu/ -user atguigu </span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>​    (3) 按文件大小，在 /home 目录下查找大于200m 的文件 (+n 大于 ，-n 小于， n 等于)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找小于10 m 的文件</span></span><br><span class="line">find tlbu/ -size -10</span><br></pre></td></tr></table></figure>


<h5 id="7-8-2-grep-在文件内搜索字符串匹配的行并输出"><a href="#7-8-2-grep-在文件内搜索字符串匹配的行并输出" class="headerlink" title="7.8.2 grep 在文件内搜索字符串匹配的行并输出"></a>7.8.2 grep 在文件内搜索字符串匹配的行并输出</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找 ll.txt</span></span><br><span class="line">ls -l |grep ll.txt</span><br></pre></td></tr></table></figure>


<h5 id="7-8-3-which-文件搜索命令"><a href="#7-8-3-which-文件搜索命令" class="headerlink" title="7.8.3 which 文件搜索命令"></a>7.8.3 <code>which</code> 文件搜索命令</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找 ls 可执行文件存放在哪里</span></span><br><span class="line">which ls</span><br></pre></td></tr></table></figure>


<h4 id="7-9-进程线程类"><a href="#7-9-进程线程类" class="headerlink" title="7.9 进程线程类"></a>7.9 进程线程类</h4><h5 id="7-9-1-ps查看系统中所有进程"><a href="#7-9-1-ps查看系统中所有进程" class="headerlink" title="7.9.1 ps查看系统中所有进程"></a>7.9.1 <code>ps</code>查看系统中所有进程</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有进程</span></span><br><span class="line">ps -aux</span><br><span class="line">grep -aux |grep 3121</span><br></pre></td></tr></table></figure>


<h5 id="7-9-2-top查看系统健康状态"><a href="#7-9-2-top查看系统健康状态" class="headerlink" title="7.9.2 top查看系统健康状态"></a>7.9.2 <code>top</code>查看系统健康状态</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">top -d 1 # 1秒刷新一次</span><br><span class="line">top -l 使top 不显示未激活的进程</span><br><span class="line">按 P 使用CPU 排序</span><br><span class="line">按 M 内存使用排序</span><br><span class="line">N pid排序</span><br></pre></td></tr></table></figure>


<h5 id="7-9-3-pstree-查看进程树"><a href="#7-9-3-pstree-查看进程树" class="headerlink" title="7.9.3 pstree 查看进程树"></a>7.9.3 <code>pstree</code> 查看进程树</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pstree</span><br><span class="line">pstree -u # 显示进程属于哪一个用户</span><br><span class="line">pstree -p # 显示pid</span><br></pre></td></tr></table></figure>


<h5 id="7-9-4-kill终止进程"><a href="#7-9-4-kill终止进程" class="headerlink" title="7.9.4 kill终止进程"></a>7.9.4 <code>kill</code>终止进程</h5><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kill</span> -<span class="number">9</span> <span class="number">3863</span> # 关闭pid 为 <span class="number">3868</span>进程 -<span class="number">9</span>（强迫关闭）</span><br></pre></td></tr></table></figure>


<h5 id="7-9-5-netstat显示网络统计信息"><a href="#7-9-5-netstat显示网络统计信息" class="headerlink" title="7.9.5 netstat显示网络统计信息"></a>7.9.5 <code>netstat</code>显示网络统计信息</h5><p>​    <code>netstat -anp</code>用来显示整个系统目前的网络情况，例如目前的连接、数据包传递数据、或是路由表内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp</span><br><span class="line">netstat -anp |grep 3897 # 显示pid 为3897 的网络情况</span><br></pre></td></tr></table></figure>


<h4 id="7-10-压缩和解压缩"><a href="#7-10-压缩和解压缩" class="headerlink" title="7.10 压缩和解压缩"></a>7.10 压缩和解压缩</h4><h5 id="7-10-1-gzip-gunzip压缩"><a href="#7-10-1-gzip-gunzip压缩" class="headerlink" title="7.10.1 gzip/gunzip压缩"></a>7.10.1 <code>gzip/gunzip</code>压缩</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip + 文件</span><br><span class="line">	功能描述：压缩文件，只能将文件压缩为 `*.gz` 文件</span><br><span class="line">	1. 只能压缩文件不能压缩目录，只能单个压缩</span><br><span class="line">	2. 不保留原来的文件</span><br><span class="line">gunzip + 文件 </span><br><span class="line">	功能：解压缩</span><br></pre></td></tr></table></figure>


<h5 id="7-10-2-zip-unzip压缩"><a href="#7-10-2-zip-unzip压缩" class="headerlink" title="7.10.2 zip/unzip压缩"></a>7.10.2 <code>zip/unzip</code>压缩</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 `zip` 同时压缩多个文件</span></span><br><span class="line">zip yijinjing ll.txt ss.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 `unzip` 解压缩</span></span><br><span class="line">unzip yijinjing.zip</span><br></pre></td></tr></table></figure>


<h5 id="7-10-3-tar打包"><a href="#7-10-3-tar打包" class="headerlink" title="7.10.3 tar打包"></a>7.10.3 <code>tar</code>打包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tar 参数 + XXX.tar.gz + 将要打包的内容</span><br><span class="line">	参数：</span><br><span class="line">		-c 产生 .tar 打包文件</span><br><span class="line">		-v 显示详细信息</span><br><span class="line">		-f 指定压缩后的文件名</span><br><span class="line">		-z 打包同时压缩</span><br><span class="line">		-x 解包 .tar 文件</span><br><span class="line"></span><br><span class="line">压缩：tar -zcvf XXX.tar.gz n1.txt n2.txt</span><br><span class="line">解压：tar -zxvf XXX.tar.gz </span><br><span class="line">    # 通过 `-C` 指定解压目录</span><br><span class="line">    tar -zxvf khbd.tar.gz -C ./wlmiji/ </span><br></pre></td></tr></table></figure>
<h4 id="7-11-后台服务管理类"><a href="#7-11-后台服务管理类" class="headerlink" title="7.11 后台服务管理类"></a>7.11 后台服务管理类</h4><h5 id="7-11-1-service-后台服务管理"><a href="#7-11-1-service-后台服务管理" class="headerlink" title="7.11.1 service 后台服务管理"></a>7.11.1 <code>service</code> 后台服务管理</h5><h5 id="7-11-2-chkconfig设置后台服务的自启配置"><a href="#7-11-2-chkconfig设置后台服务的自启配置" class="headerlink" title="7.11.2 chkconfig设置后台服务的自启配置"></a>7.11.2 <code>chkconfig</code>设置后台服务的自启配置</h5><h4 id="7-12-crond系统定时任务"><a href="#7-12-crond系统定时任务" class="headerlink" title="7.12 crond系统定时任务"></a>7.12 <code>crond</code>系统定时任务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab [选项]</span><br><span class="line">选项：</span><br><span class="line">	-e : 编辑 crontab 定时任务</span><br><span class="line">	-l : 查询 crontab 任务</span><br><span class="line">	-r : 删除当前用户所有的 crontab 任务</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p><code>crontab -e</code></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个 “*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个 “*”</td>
<td>一天当中的第几个小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个 “*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个 “*”</td>
<td>一年当中的第几个月</td>
<td>1-12</td>
</tr>
<tr>
<td>第无个 “*”</td>
<td>一周单中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">进入 crontab 编辑界面，会打开 vim 编辑你的工作。</span><br><span class="line">1 16 1 5 * 执行的任务(echo &quot;hello world&quot;&gt;&gt;/home/atguigu/t.txt)</span><br></pre></td></tr></table></figure>
<p>特殊字符：</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间。<br />比如第一个”*”就代表一小时中每分钟都执行一次</td>
</tr>
<tr>
<td>,</td>
<td>代表不连续的时间<br />比如”0 8,12,16 ***”命令，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围<br />比如”0 5 * * 1-6”,代表在周一到周六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次<br />比如”*/10 * * * *”命令，代表每个10分钟就执行一遍命令</td>
</tr>
</tbody></table>
<p>特定时间执行命令</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>45 22 * * * 命令</td>
<td>在22点45分执行命令</td>
</tr>
</tbody></table>
<h3 id="八、rpm"><a href="#八、rpm" class="headerlink" title="八、rpm"></a>八、<code>rpm</code></h3><p>​    RPM (RedHat Package Manager)，Rethat 软件包管理工具，是LINUX这一系列操作系统里面的打包安装工具，它虽然是RatHat的标志，但理念是通用的</p>
<h4 id="8-2-1-查询"><a href="#8-2-1-查询" class="headerlink" title="8.2.1 查询"></a>8.2.1 查询</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa # 功能：查询安装的所有软件</span><br><span class="line">rpm -qa |grep fire</span><br></pre></td></tr></table></figure>
<h4 id="8-2-2-卸载"><a href="#8-2-2-卸载" class="headerlink" title="8.2.2 卸载"></a>8.2.2 卸载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -e firefox-52.8.0-1.el6.centos.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="8-2-3-安装"><a href="#8-2-3-安装" class="headerlink" title="8.2.3 安装"></a>8.2.3 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh RPM包全名</span><br><span class="line">	-i=install ，安装</span><br><span class="line">	-v=verbose , 显示详细信息</span><br><span class="line">	-h=hash , 进度条</span><br><span class="line">	-nodeps , 不检测依赖进度</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="九、shell编程"><a href="#九、shell编程" class="headerlink" title="九、shell编程"></a>九、<code>shell</code>编程</h3><h4 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h4><p><code>Shell</code>是一个命令行解释器，它为用户提供了一个向<code>Linux</code>内核发送请求以便运行程序的界面系统级程序，用户可以用<code>Shell</code>来启动、挂起、停止甚至是编写一些程序。</p>
<h4 id="9-2-shell脚本的执行方式"><a href="#9-2-shell脚本的执行方式" class="headerlink" title="9.2 shell脚本的执行方式"></a>9.2 <code>shell</code>脚本的执行方式</h4><h5 id="1）echo输出内容到控制台"><a href="#1）echo输出内容到控制台" class="headerlink" title="1）echo输出内容到控制台"></a>1）<code>echo</code>输出内容到控制台</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项内容] [输出内容]</span><br><span class="line"><span class="built_in">echo</span> -e 转义字符</span><br><span class="line">	</span><br><span class="line">	控制字符		作	用</span><br><span class="line">	\\			   输出 \ 本身</span><br><span class="line">	\a			   输出警告音</span><br><span class="line">	\b			   退格键，也就是向左删除键</span><br><span class="line">	\c			   取消输出行末的换行符。 和 <span class="string">&quot;-n&quot;</span> 选项一致</span><br><span class="line">	\e			   ESCAPE 键</span><br><span class="line">	\f			   换页符</span><br><span class="line">	\n             换行符</span><br><span class="line">	\r			   回车键</span><br><span class="line">	\t			   制表符，也就是 Tab 键</span><br><span class="line">	\v			   垂直制表符</span><br><span class="line">	\0nnn		   按照八进制ASCII码表输出字符。其中0是数字零，nnn是三位八进制数</span><br><span class="line">	\xhh		   按照十六进制ASCII码表输出字符，其中hh是两位十六进制数</span><br></pre></td></tr></table></figure>


<h5 id="2）脚本格式"><a href="#2）脚本格式" class="headerlink" title="2）脚本格式"></a>2）脚本格式</h5><ul>
<li>脚本是以 <code>#!/bin/bash</code>开头</li>
</ul>
<h5 id="3）第一个shell脚本"><a href="#3）第一个shell脚本" class="headerlink" title="3）第一个shell脚本"></a>3）第一个<code>shell</code>脚本</h5><p><strong>需求</strong>：输出<code>Hello world!</code></p>
<p><strong>shell 脚本</strong> - <code>helloworld.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>


<h5 id="4）脚本的常用执行方式"><a href="#4）脚本的常用执行方式" class="headerlink" title="4）脚本的常用执行方式"></a>4）脚本的常用执行方式</h5><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">./helloworld.<span class="keyword">sh</span></span><br><span class="line">/<span class="keyword">opt</span>/shuihu/helloworld.<span class="keyword">sh</span></span><br><span class="line"><span class="keyword">sh</span> ./helloworld.<span class="keyword">sh</span></span><br><span class="line">bash ./helloworld.<span class="keyword">sh</span></span><br><span class="line"><span class="keyword">sh</span> /<span class="keyword">opt</span>/shuihu/helloworld.<span class="keyword">sh</span></span><br><span class="line">bash /<span class="keyword">opt</span>/shuihu/helloworld.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>


<h4 id="9-3-shell中的变量"><a href="#9-3-shell中的变量" class="headerlink" title="9.3 shell中的变量"></a>9.3 <code>shell</code>中的变量</h4><p><strong>概述：</strong></p>
<ol>
<li><code>LinuxShell</code>中变量分为”系统变量”和”用户自定义变量”，可以通过<code>set</code>命令查看系统变量</li>
<li>系统变量：<code>$HOME $PWD $SHELL $USER</code>等等</li>
<li>显示当前 <code>shell</code> 中所有的变量：<code>set</code></li>
</ol>
<h5 id="9-3-1-定义变量"><a href="#9-3-1-定义变量" class="headerlink" title="9.3.1 定义变量"></a>9.3.1 定义变量</h5><ol>
<li>基本语法<ul>
<li><strong>定义变量</strong>: 变量=值</li>
<li><strong>撤销变量</strong>：unset 变量</li>
<li><strong>声明静态变量</strong>：readonly 变量</li>
</ul>
</li>
<li>变量定义规则<ul>
<li><strong>等号两侧不能有空格</strong></li>
<li>变量名称一般为<strong>大写</strong></li>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</li>
<li><strong>双引号和单引号区别</strong>：双引号仅将空格脱意 ，单引号会将所有特殊字符脱意</li>
</ul>
</li>
<li>案例</li>
</ol>
<h5 id="9-3-2-将命令的返回值赋给变量"><a href="#9-3-2-将命令的返回值赋给变量" class="headerlink" title="9.3.2 将命令的返回值赋给变量"></a>9.3.2 将命令的返回值赋给变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行 `ls -al` 命令，并将结果返回给变量A,注意为反引号``</span></span><br><span class="line">A=`ls -al`</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">A=$(ls-al)</span><br></pre></td></tr></table></figure>


<h5 id="9-3-3-设置环境变量"><a href="#9-3-3-设置环境变量" class="headerlink" title="9.3.3 设置环境变量"></a>9.3.3 设置环境变量</h5><ol>
<li>基本语法<ul>
<li><code>export 变量名=变量值</code>    （功能描述：设置环境变量的值，提升为全局变量）</li>
<li><code>source配置文件</code>       （功能描述：让修改后的配置信息立即生效）</li>
<li><code>echo $变量名</code>          (功能描述：查询环境变量的值)</li>
</ul>
</li>
</ol>
<h5 id="9-3-4-位置参数变量"><a href="#9-3-4-位置参数变量" class="headerlink" title="9.3.4 位置参数变量"></a>9.3.4 位置参数变量</h5><p>​    <strong>基本语法：</strong></p>
<pre><code> 1. `$n` : 功能描述：n 为数字, $0 代表**命令本身**，`$1-$9` 代表第一到第九个参数，十个以上的参数，需要用大括号包含，如 `$&#123;10&#125;`
 2. `$*` : 功能描述： 这个变量代表命令行中所有的参数，`$*`把所有的参数看成一个整体
 3. `$@`: 功能描述： 这个变量也代表命令行中所有的参数，不过 `$@`把每一个参数区别对待
 4. `$#` : 功能描述： 这个变量代表命令行中所有的参数的个数</code></pre>
<h5 id="9-3-5-预定义变量"><a href="#9-3-5-预定义变量" class="headerlink" title="9.3.5 预定义变量"></a>9.3.5 预定义变量</h5><p><strong>基本语法</strong>：</p>
<ol>
<li><code>$$</code> : 当前进程的进程号 (PID)</li>
<li><code>$!</code> : 后台运行的最后一个进程的进程号</li>
<li><code>$?</code> : 最后一次执行的命令的返回状态。如果这个变量的值为 0 ，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，有命令自己来决定)，则证明上一个命名执行不正确了。</li>
</ol>
<h4 id="9-4-运算符"><a href="#9-4-运算符" class="headerlink" title="9.4 运算符"></a>9.4 运算符</h4><ol>
<li><p>基本语法：</p>
<ul>
<li>“$((运算式))” 或 “$[运算式]”</li>
<li>expr m + n      <em>注意：expr运算符之间要有空格</em></li>
<li>expr m - n      <em>注意：expr 运算符之间要有空格</em></li>
<li>/*,/,%          <em>乘，除，取余</em></li>
</ul>
</li>
<li><p>案例</p>
<p>计算 （2 + 3 ）* 4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $[(2+3)*4]</span><br><span class="line">expr `expr 2 + 3` \* 4</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="9-5-条件判断"><a href="#9-5-条件判断" class="headerlink" title="9.5 条件判断"></a>9.5 条件判断</h4><h5 id="9-5-1-判断语句"><a href="#9-5-1-判断语句" class="headerlink" title="9.5.1 判断语句"></a>9.5.1 判断语句</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ condition ] # 注意：condition 前后要有空格</span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ atguigu ]	返回 true</span><br><span class="line"></span><br><span class="line">[]	返回 false</span><br><span class="line"></span><br><span class="line">[ condition ] &amp;&amp; echo OK || echo notok	条件满足，执行后面的语句</span><br></pre></td></tr></table></figure>


<h5 id="9-5-2-常用条件判断"><a href="#9-5-2-常用条件判断" class="headerlink" title="9.5.2 常用条件判断"></a>9.5.2 常用条件判断</h5><ol>
<li><p><strong>两个整数之间的比较</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=	字符串比较</span><br><span class="line">-lt	小于</span><br><span class="line">-le	小于等于</span><br><span class="line">-eq	等于</span><br><span class="line">-gt	大于</span><br><span class="line">-ge	大于等于</span><br><span class="line">-ne	不等于</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p><strong>按照文件权限进行判断</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-r	有读的权限</span><br><span class="line">-w	有写的权限</span><br><span class="line">-x	有执行的权限</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p><strong>按照文件类型进行判断</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-f	文件存在并且是一个常规的文件</span><br><span class="line">-e	文件存在</span><br><span class="line">-d	文件存在并是一个目录</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p><strong>案例</strong></p>
<table>
<thead>
<tr>
<th>23是否大于等于22</th>
<th>[ 23 -get 22]</th>
</tr>
</thead>
<tbody><tr>
<td><code>student.txt</code>是否具有写权限</td>
<td>[ -w student.txt]</td>
</tr>
<tr>
<td><code>/root/install.log</code> 目录中的文件是否存在</td>
<td>[ -e /root/install.log ]</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="9-6-流程控制"><a href="#9-6-流程控制" class="headerlink" title="9.6 流程控制"></a>9.6 流程控制</h4><h5 id="9-6-1-if-判断"><a href="#9-6-1-if-判断" class="headerlink" title="9.6.1 if 判断"></a>9.6.1 if 判断</h5><ol>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line"></span><br><span class="line">if[ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">if[ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">    	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>： 1、[ 条件判断式 ] ，中括号和条件判断式之间必须有空格</p>
</li>
<li><p>案例<br>判断输入的数是否等于123，是否等于456</p>
<p><code>./if.sh 123</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq &quot;123&quot; ]</span><br><span class="line">	then</span><br><span class="line">	echo &quot;123&quot;</span><br><span class="line">	</span><br><span class="line">elif [ $1 -eq &quot;456&quot; ]</span><br><span class="line">	then</span><br><span class="line">	echo &quot;456&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="9-6-2-case-语句"><a href="#9-6-2-case-语句" class="headerlink" title="9.6.2 case 语句"></a>9.6.2 case 语句</h5><ol>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">	如果变量的值等于值1，则执行程序1</span><br><span class="line">	;;</span><br><span class="line">	&quot;值2&quot;）</span><br><span class="line">	如果变量的值等于值2，则执行程序2</span><br><span class="line">	;;</span><br><span class="line">	...省略其他分支...</span><br><span class="line">	*)</span><br><span class="line">	如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">	;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>案例</p>
<p>输入1，输出1；输入2，输出2 ； 输入其他，输出other;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">	echo 1</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">&quot;2&quot;)</span><br><span class="line">	echo 2</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line">	echo &quot;other&quot;</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="9-6-3-for-循环"><a href="#9-6-3-for-循环" class="headerlink" title="9.6.3 for 循环"></a>9.6.3 for 循环</h5><ol>
<li><p><strong>基本语法1</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>案例1<br>打印输入参数<br><code>for1.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;$i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;$j&quot;</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./ for1.sh 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line">1 2 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p><strong>基本语法2</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>案例2</p>
<p>从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for ((i=1;i &lt;= 100; i++))</span><br><span class="line">do</span><br><span class="line">	s=$[$s+$i]	</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="9-6-4-while-循环"><a href="#9-6-4-while-循环" class="headerlink" title="9.6.4 while 循环"></a>9.6.4 while 循环</h5><ol>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>案例<br>从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">	s=$[$s + $i]</span><br><span class="line">	i=$[$i + 1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;$s&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="9-7-read读取控制台输入"><a href="#9-7-read读取控制台输入" class="headerlink" title="9.7 read读取控制台输入"></a>9.7 <code>read</code>读取控制台输入</h4><ol>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read (选项)(参数)</span><br><span class="line">	选项：</span><br><span class="line">		-p ：指定读取值时的提示符；</span><br><span class="line">		-t : 指定读取值时等待的时间(秒)</span><br><span class="line">	参数：</span><br><span class="line">		</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>案例<br>读取控制台输入的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 将输入的内容赋值给 `NAME`</span><br><span class="line">read -p &quot;input your name &quot; NAME</span><br><span class="line">echo $NAME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 5 秒 内输入的内容赋值给 `NAME`</span></span><br><span class="line">read -t 5 -p &quot;input your name&quot; NAME</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="9-8-函数"><a href="#9-8-函数" class="headerlink" title="9.8 函数"></a>9.8 函数</h4><h5 id="9-8-1-系统函数"><a href="#9-8-1-系统函数" class="headerlink" title="9.8.1 系统函数"></a>9.8.1 系统函数</h5><ol>
<li><p><code>basename</code>基本语法</p>
</li>
<li><p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basename /opt/shuihu/for1.sh </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; for1.sh</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p><code>dirname</code>基本语法</p>
</li>
<li><p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basename /opt/shuihu/for1.sh </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; /opt/shuihu</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="9-8-2-自定义函数"><a href="#9-8-2-自定义函数" class="headerlink" title="9.8.2 自定义函数"></a>9.8.2 自定义函数</h5><ol>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    Action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funname</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>必须在调用函数地方之前，先声明函数，shell 脚本是逐行运行。不会像其它语言一样先编译</li>
<li>函数返回值，只能通过<code>$?</code>系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值 n (0-255)</li>
</ul>
</li>
<li><p>案例</p>
<p>计算输入参数的和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">funciton sum()</span><br><span class="line">&#123;</span><br><span class="line">    s=0</span><br><span class="line">    s=$[$1 + $2]</span><br><span class="line">    echo &quot;$s&quot;</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;Please input the number1:&quot; n1;</span><br><span class="line">read -p &quot;Please input the number2:&quot; n2;</span><br><span class="line">sum $n1 $n2;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="十、yum-仓库配置"><a href="#十、yum-仓库配置" class="headerlink" title="十、yum 仓库配置"></a>十、<code>yum</code> 仓库配置</h3><h4 id="10-1概述"><a href="#10-1概述" class="headerlink" title="10.1概述"></a>10.1概述</h4><p><code>YUM</code> （全称 为 <code>Yellow dog Updater,Modified</code>）是一个在 <code>Fedora</code>和 <code>RedHat</code>以及<code>CentOS</code>中的<code>Shell</code>前端软件包管理器。</p>
<p>基于<code>RPM</code>包管理，能够从指定的服务器自动下载<code>RPM</code>包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无需繁琐地一次次下载、安装。</p>
<h4 id="10-2-yum-的常用命令"><a href="#10-2-yum-的常用命令" class="headerlink" title="10.2 yum 的常用命令"></a>10.2 yum 的常用命令</h4><h5 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y httpd	(功能描述：安装 httpd 并确认安装)</span><br><span class="line">yum list				(功能描述：列出所有可用的 package 和 package 组)</span><br><span class="line">yum clean all			(功能描述：清除所有缓冲数据)</span><br><span class="line">yum deplist httpd		(功能描述：列出一个包所有依赖的包)</span><br><span class="line">yum remove httpd		(功能描述：删除 httpd)</span><br></pre></td></tr></table></figure>


<h5 id="2-案例"><a href="#2-案例" class="headerlink" title="2. 案例"></a>2. 案例</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y tree</span><br></pre></td></tr></table></figure>


<h4 id="10-3-关联网络-yum-源"><a href="#10-3-关联网络-yum-源" class="headerlink" title="10.3 关联网络 yum 源"></a>10.3 关联网络 yum 源</h4><p><strong>在线安装</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># 首先下载网易 <span class="selector-tag">yum</span> 配置文件，将该文件 移动到 /<span class="selector-tag">etc</span>/<span class="selector-tag">yum</span><span class="selector-class">.repos</span><span class="selector-class">.d</span>/ 文件夹内</span><br><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">CentOS6-Base-163</span><span class="selector-class">.repo</span> /<span class="selector-tag">etc</span>/<span class="selector-tag">yum</span><span class="selector-class">.repos</span><span class="selector-class">.d</span>/</span><br><span class="line"><span class="selector-tag">cd</span> /<span class="selector-tag">etc</span>/<span class="selector-tag">yum</span><span class="selector-class">.repos</span><span class="selector-class">.d</span>/</span><br><span class="line"># 将 <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span> 备份 为 <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span><span class="selector-class">.bak</span></span><br><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span> <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span><span class="selector-class">.bak</span></span><br><span class="line"># 将下载的网易 <span class="selector-tag">yum</span> 配置文件 <span class="selector-tag">CentOS6-Base-163</span><span class="selector-class">.repo</span> 改名为 <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span></span><br><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">CentOS6-Base-163</span><span class="selector-class">.repo</span> <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span></span><br><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">CentOS-Base</span><span class="selector-class">.repo</span></span><br><span class="line"># 清除缓存</span><br><span class="line"><span class="selector-tag">yum</span> <span class="selector-tag">clean</span> <span class="selector-tag">all</span></span><br><span class="line"># 安装</span><br><span class="line"><span class="selector-tag">yum</span> <span class="selector-tag">makecache</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>制作本地yum源</strong></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Request和Respons</title>
    <url>/2019/06/02/Request%E5%92%8CRespons/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h4 id="request对象-和-response-对象的原理"><a href="#request对象-和-response-对象的原理" class="headerlink" title="request对象 和 response 对象的原理"></a>request对象 和 response 对象的原理</h4><ol>
<li>request 和 response 对象是由服务器创建的。我们只是来使用它们</li>
<li>request 是来 获取请求消息 ， response 对象是来设置响应消息</li>
</ol>
<h5 id="浏览器访问服务器过程"><a href="#浏览器访问服务器过程" class="headerlink" title="浏览器访问服务器过程"></a>浏览器访问服务器过程</h5><ol>
<li>tomcat 服务器会根据请求 url 中资源路径，创建对应的 ServletDemo1 的 对象。</li>
<li>tomcat 服务器，会创建 request 和 response 对象，request 对象中封装请求消息数据。</li>
<li>tomcat 将 request 和 response 两个对象传递给 service() 方法，并且调用 service 方法。</li>
<li>我们可以通过 request 对象获取请求消息数据，通过 response 对象设置响应消息数据。</li>
<li>服务器在给浏览器做出响应之前，会从 response 对象中拿程序员设置的响应消息数据。</li>
</ol>
<h4 id="request-对象继承体系结构-："><a href="#request-对象继承体系结构-：" class="headerlink" title="request 对象继承体系结构 ："></a>request 对象继承体系结构 ：</h4><pre class="mermaid">graph BT
    B[HttpServletRequest `接口`] -->|继承| A[ServletRequest `接口`]
    C[org.apache.catalina.connector.RequestFacade `类` *tomact编写* ] -->|实现| B</pre>



<h4 id="request-功能"><a href="#request-功能" class="headerlink" title="request 功能"></a>request 功能</h4><ol>
<li><p>获取请求消息数据</p>
<ol>
<li><p>获取请求行数据</p>
<ul>
<li><p>GET /day14/demo1?name=zhangsan HTTP/1.1</p>
</li>
<li><p>方法 ：</p>
<ol>
<li><p>获取请求方式 ：GET</p>
<ul>
<li>String getMethod()</li>
</ul>
</li>
<li><p>(*)<strong>获取虚拟目录</strong> ：/day14</p>
<ul>
<li>String getContextPath()</li>
</ul>
</li>
<li><p>获取Servlet路径 ：/demo1</p>
<ul>
<li>String getServletPath()</li>
</ul>
</li>
<li><p>获取get方式的请求参数 ：name=zhangsan</p>
<ul>
<li>String getQueryString()</li>
</ul>
</li>
<li><p>(*)<strong>获取请求的URI</strong> : /day14/demo1</p>
<ul>
<li><p>String getRequestURI() : /day14/demo1</p>
</li>
<li><p>StringBuffer getRequestURL() : <a href="http://localhost/day4/demo1">http://localhost/day4/demo1</a></p>
</li>
<li><hr>
</li>
<li><p>URL : 统一资源定位符 ：<code>http://localhost/day4/demo1</code></p>
</li>
<li><p>URI :  统一资源标识符 ：<code>/day14/demo1</code>   表示的范围更大</p>
</li>
</ul>
</li>
<li><p>获取协议及版本 ： HTTP/1.1</p>
<ul>
<li>String getProtocol() </li>
</ul>
</li>
<li><p>获取客户机的 IP 地址 ：</p>
<ul>
<li>String getRemoteAddr()</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>获取请求头数据</p>
<ul>
<li>方法<ul>
<li>(*) <strong>String getHeader(String name)</strong> : 通过请求头的名称获取请求头的值</li>
<li>Enumeration<String>  getHeaderNames() : 获取所有的请求头的名称</li>
</ul>
</li>
</ul>
</li>
<li><p>获取请求体数据</p>
<ul>
<li>请求体 ：只有 POST请求方式，才有请求体，在请求体中封装了post请求的请求参数</li>
<li>步骤：<ol>
<li>获取流对象<ul>
<li>BufferedReader getReader() : 获取字节输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream() : 获取字节输入流，可以操作所有类型数据<ul>
<li>在文件上传知识点后</li>
</ul>
</li>
</ul>
</li>
<li>再从流对象中拿数据 </li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>其他功能 :</p>
<ol>
<li><p>获取请求参数 通用方式</p>
<ol>
<li>String getParameter(String name) : 根据参数名称获取参数值    username=zs&amp;password=123</li>
<li>String[] getParameterValues(String name) : 根据参数名称获取参数值    habby=xx&amp;habby=game</li>
<li>Enumeration<String> getParameterNames() : 获取所有请求参数的名称</li>
<li>Map&lt;String,String[]&gt; getParameterMap() : 获取所有参数的map集合</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>  * 中文乱码问题：
    * get方式 ： Tomcat 8 以后已经解决
    * post 方式 ：在获取请求参数前，设置编码方式 ：`req.setCharacterEncoding(&quot;utf-8&quot;);`</code></pre>
<ol start="2">
<li><p>请求转发 ：一种在服务器内部的资源跳转方式</p>
<ol>
<li>步骤 ：<ol>
<li>通过 request 对象获取请求转发器对象 ： RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用 RequestDispatcher 对象来进行转发 ：foward(ServletRequest request, ServletResponse response)</li>
</ol>
</li>
<li>特点 ：<ol>
<li>浏览器地址栏路径不会发生变化</li>
<li>只能转发到当前服务器内部资源中</li>
<li>转发只是<strong>一次</strong>请求</li>
</ol>
</li>
</ol>
</li>
<li><p>共享数据：</p>
<ul>
<li><strong>域对象</strong> ：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域 ：代表<strong>一次请求</strong>的范围，一般用于请求转发的多个资源中共享数据</li>
<li>方法 ：<ol>
<li>void setAttribute(String name, Object obj) ：存储数据</li>
<li>Object getAttribute(String name) : 通过建获取值</li>
<li>void removeAttribute(String name) : 通过键移除键值对</li>
</ol>
</li>
</ul>
</li>
<li><p>获取 ServletContext</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
<h3 id="案例-：用户登录"><a href="#案例-：用户登录" class="headerlink" title="案例 ：用户登录"></a>案例 ：用户登录</h3><ul>
<li><p>用户登录案例需求 ：</p>
<ol>
<li>编写 login.html 登录页面<br>username &amp; password 两个输入框</li>
<li>使用 Druid 数据库连接池技术，操作 mysql ，day14 数据库中的 user 表</li>
<li>使用 jdbcTemplate技术封装 JDBC</li>
<li>登录成功跳转 SuccessServlet展示：登录成功！用户名，欢迎您</li>
<li>登录失败跳转 FailServlet 展示 ：登录失败，用户名或密码错误！</li>
</ol>
</li>
<li><p>分析</p>
</li>
<li><p>开发步骤</p>
<ol>
<li><p>创建项目，导入HTML，配置文件，jar包</p>
</li>
<li><p>创建数据库环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database day14;</span><br><span class="line">mysql&gt; use day14;</span><br><span class="line">mysql&gt; create table user(</span><br><span class="line">    -&gt; id int primary key auto_increment,</span><br><span class="line">    -&gt; username varchar(32) unique not null,</span><br><span class="line">    -&gt; password varchar(32) not null);</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>创建包 <code>cn.itcast.domain</code>，创建类<code>User</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>创建包 <code>cn.itcast.util</code>，创建类<code>JDBCUtil</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC 工具类 使用 Durid 连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 使用 ClassLoader 加载配置文件，获取字节输入流</span></span><br><span class="line">            InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 初始化连接池对象</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接 Connection 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>创建包 <code>cn.itcast.dao</code>，创建类<code>UserDao</code>，提供 <code>login()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.util.JDBCUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作数据库中User表的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明JDBCTemplate 对象共用</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtil.getDataSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginUser 只有用户名和密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user 包含用户全部数据,没有查询到，返回 Null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User loginUser)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.编写sql</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">            <span class="comment">// 2.编写query方法</span></span><br><span class="line">            User user = template.queryForObject(sql,</span><br><span class="line">                    <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class),</span><br><span class="line">                    loginUser.getUsername(),</span><br><span class="line">                    loginUser.getPassword());</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>编写 cn.itcast.web.servlet.LoginServlet类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.Dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/loginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.设置编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.获取请求参数 ： 用户名密码</span></span><br><span class="line">        String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 封装 User 对象 ：将用户名密码封装</span></span><br><span class="line">        User loginUser = <span class="keyword">new</span> User();</span><br><span class="line">        loginUser.setUsername(username);</span><br><span class="line">        loginUser.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.调用UserDao的 login 方法</span></span><br><span class="line">        UserDao dao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        User user = dao.login(loginUser);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 登录失败，转发到 FailServlet</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/failServlet&quot;</span>).forward(request,response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录成功</span></span><br><span class="line">            <span class="comment">// 存储</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">            <span class="comment">// 转发到 SuccessServlet</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/successServlet&quot;</span>).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="7">
<li><p>login.html 中 from 表单的action路径的写法 ：</p>
<ul>
<li>虚拟目录 + Servlet的资源路径</li>
</ul>
</li>
<li><p>编写 cn.itcast.web.servlet.FailServlet类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/failServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在页面上打印内容</span></span><br><span class="line">        <span class="comment">// 设置编码</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;登录失败，用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="9">
<li><p>编写 cn.itcast.web.servlet.SuccessServlet类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/successServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取request域中共享的user对象存储内容</span></span><br><span class="line">        User user = (User) request.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;登录成功，&quot;</span> + user.getUsername() + <span class="string">&quot;，欢迎您！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="10">
<li><p><strong>BeanUtils</strong>工具类，简化数据封装</p>
<ul>
<li><p>用于封装 JavaBean的</p>
<ol>
<li><p>JavaBean : 标准的Java类</p>
<ol>
<li>要求 ：<ol>
<li>类必须被public修饰</li>
<li>必须提供 空参 的构造器</li>
<li>成员变量必须使用 private 修饰</li>
<li>提供公共 setter 和 getter 方法</li>
</ol>
</li>
</ol>
</li>
<li><p>概念 ：</p>
<p><strong>成员变量</strong> ：</p>
<p><strong>属性</strong> ：setter 和 getter 方法截取后的产物</p>
<p>​    例如 ： getUsername() –&gt; Username – &gt; username</p>
</li>
<li><p>方法 ：</p>
<ol>
<li><em>setProperty()</em> : 设置<strong>属性</strong>值</li>
<li><em>getProperty() :</em></li>
<li><em>populate(Object obj,Map map)</em> : 将 map 集合中的健值对信息，封装到对应的 JavaBean 对象中</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Request</category>
        <category>Respons</category>
      </categories>
      <tags>
        <tag>Request</tag>
        <tag>Respons</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Response笔记</title>
    <url>/2019/06/02/Response%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>HTTP协议：响应消息</li>
<li>Response对象</li>
<li>ServletContext对象</li>
</ol>
<h2 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h2><ol>
<li>请求消息：客户端发送给服务器端的数据</li>
</ol>
<ul>
<li>数据格式：<ol>
<li>请求行</li>
<li>请求头</li>
<li>请求空行</li>
<li>请求体</li>
<li>响应消息：服务器端发送给客户端的数据</li>
</ol>
</li>
<li>数据格式：</li>
</ul>
<ol>
<li>响应行<ol>
<li>组成：协议/版本 响应状态码 状态码描述</li>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol>
<li>状态码都是3位数字 </li>
<li>分类：<ol>
<li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li>
<li>4xx：客户端错误。<ul>
<li>代表：</li>
<li>404（请求路径没有对应的资源） </li>
<li>405：请求方式没有对应的doXxx方法</li>
</ul>
</li>
<li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li>响应头：<br>​    1. 格式：头名称： 值<br>​    2. 常见的响应头：<br>​        1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式<br>​        2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据<br>​        * 值：<br>​            * <em>in-line</em>:默认值,在当前页面内打开<br>​            * <em>attachment;filename=xxx</em>：以附件形式打开响应体。文件下载</li>
<li> 响应空行</li>
<li> 响应体:传输的数据</li>
</ol>
<ul>
<li><p>响应字符串格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Wed, 06 Jun 2018 07:08:42 GMT</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  hello , response</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>* 功能：设置响应消息
    1. 设置响应行
        1. 格式：HTTP/1.1 200 ok
        2. 设置状态码：setStatus(int sc) 
    2. 设置响应头：setHeader(String name, String value) 

    3. 设置响应体：
        * 使用步骤：
            1. 获取输出流
                * 字符输出流：PrintWriter getWriter()

                * 字节输出流：ServletOutputStream getOutputStream()

            2. 使用输出流，将数据输出到客户端浏览器


* 案例：
    1. 完成重定向
        * 重定向：资源跳转的方式
        * 代码实现：
            //1. 设置状态码为302
            response.setStatus(302);
            //2.设置响应头location
            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);


            //简单的重定向方法
            response.sendRedirect(&quot;/day15/responseDemo2&quot;);

        * 重定向的特点:redirect
            1. 地址栏发生变化
            2. 重定向可以访问其他站点(服务器)的资源
            3. 重定向是两次请求。不能使用request对象来共享数据
        * 转发的特点：forward
            1. 转发地址栏路径不变
            2. 转发只能访问当前服务器下的资源
            3. 转发是一次请求，可以使用request对象来共享数据

        * forward 和  redirect 区别

        * 路径写法：
            1. 路径分类
                1. 相对路径：通过相对路径不可以确定唯一资源
                    * 如：./index.html
                    * 不以/开头，以.开头路径

                    * 规则：找到当前资源和目标资源之间的相对位置关系
                        * ./：当前目录
                        * ../:后退一级目录
                2. 绝对路径：通过绝对路径可以确定唯一资源
                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2
                    * 以/开头的路径

                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
                            * 建议虚拟目录动态获取：request.getContextPath()
                            * &lt;a&gt; , &lt;form&gt; 重定向...
                        * 给服务器使用：不需要加虚拟目录
                            * 转发路径</code></pre>
<p>​<br>​                        </p>
<pre><code>    2. 服务器输出字符数据到浏览器
        * 步骤：
            1. 获取字符输出流
            2. 输出数据

        * 注意：
            * 乱码问题：
                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
                2. 设置该流的默认编码
                3. 告诉浏览器响应体使用的编码

                //简单的形式，设置编码，是在获取流之前设置
                response.setContentType(&quot;text/html;charset=utf-8&quot;);
    3. 服务器输出字节数据到浏览器
        * 步骤：
            1. 获取字节输出流
            2. 输出数据

    4. 验证码
        1. 本质：图片
        2. 目的：防止恶意表单注册</code></pre>
<h2 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h2><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信
2. 获取：
    1. 通过request对象获取
        request.getServletContext();
    2. 通过HttpServlet获取
        this.getServletContext();
3. 功能：
    1. 获取MIME类型：
        * MIME类型:在互联网通信过程中定义的一种文件数据类型
            * 格式： 大类型/小类型   text/html        image/jpeg

        * 获取：String getMimeType(String file)  
    2. 域对象：共享数据
        1. setAttribute(String name,Object value)
        2. getAttribute(String name)
        3. removeAttribute(String name)

        * ServletContext对象范围：所有用户所有请求的数据
    3. 获取文件的真实(服务器)路径
        1. 方法：String getRealPath(String path)  
             String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问
             System.out.println(b);

            String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问
            System.out.println(c);

            String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问
            System.out.println(a);</code></pre>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流


* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>Request</category>
        <category>Respons</category>
      </categories>
      <tags>
        <tag>Request</tag>
        <tag>Respons</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础</title>
    <url>/2019/01/09/linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>帮助命令： man 获得帮助信息 用法：man [命令或配置文件]</li>
<li>help 获得shell内置命令的帮助信息</li>
</ul>
<h5 id="基础命令："><a href="#基础命令：" class="headerlink" title="基础命令："></a>基础命令：</h5><ol>
<li><p>pwd 查看绝对路径</p>
</li>
<li><p>mkidr 创建一个新的目录</p>
</li>
<li><p>rmdir 删除一个空的目录</p>
</li>
<li><p>touch 创建空文件</p>
</li>
<li><p>cd 切换目录 用法：（cd 绝对路径/相对路径）</p>
<p>  cd 绝对路径</p>
<pre><code>      cd 相对路径
      cd ~ 或 cd 回到自己的家目录
      cd - 回到上一次所在目录
      cd.. 回到当前目录的上一级目录</code></pre>
</li>
<li><p>cp 复制文件或目录</p>
<pre><code> cp source dest    复制source文件到dest
 cp -r sourceFloder targetFolder        递归复制整个文件到</code></pre>
</li>
<li><p>ls 列出目录内容 （-a/-l）</p>
</li>
<li><p>ll</p>
</li>
<li><p>rm 移除文件或目录</p>
<pre><code> rm 删除文件
 rm -rf 递归删除，可以删除包含文件的文件夹</code></pre>
</li>
<li><p>mv 移动文件与目录或重命名</p>
<pre><code>mv oldNameFile newNameFile    重命名
mv /temp/movefile/targetFolder 移动文件</code></pre>
</li>
<li><p>cat 查看文件内容</p>
<pre><code>查看文件内容，从第一行开始显示。
cat -n 显示行号，连同空白行也会有
cat -A 累出一些特殊字符，而不是空白而已
cat -b 列出行号，但针对非空白行做行号显示，空白行不标行号!
cat -E 将结尾的断行字符$显示出来；
cat -T 将【Tab】键以 ^|显示出来；
cat -v 列出一些看不出来的特殊字符；</code></pre>
</li>
<li><p>tac 查看文件内容</p>
<pre><code>查看文件内容，从最后一行开始显示，可以看出tac 是 cat 的倒着写的；</code></pre>
</li>
<li><p>more 查看文件内容</p>
<pre><code>more 要查看的文件
空白键[space]    代表向下翻一页
Enter    代表向下翻一行
q        代表离开more ，不在显示该文件内容;
Ctrl + F    向下滚动一屏
Ctrl + B    返回上一屏
=输出当前行的行号
:f    输出文件名和当前行的行号;</code></pre>
</li>
<li><p>less 查看文件内容</p>
<pre><code>less的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less允许使用[pageup][pagedown]往回滚动；
空白键    向下翻动一页
[pagedown]    向下翻动一页
[pageup]    向上翻动一页
/字符串        向下搜寻[字符串]的功能;n:向下查找；N:向上查找
?字符串        向上搜寻[字符串]的功能;n:向上查找;    N:向下查找
q        离开less</code></pre>
</li>
<li><p>head 查看文件内容</p>
<pre><code>查看文件内容，只看头几行</code></pre>
</li>
<li><p>tail 查看文件内容</p>
<pre><code>查看文件内容，只看尾巴几行
tail -n 10 文件    
tail -f 文件        实时追踪该文档的所有更新</code></pre>
</li>
<li><p>重定向命令</p>
<pre><code>ls -l &gt;文件        列表的内容写入文件a.txt中(覆盖写)
ls -al &gt;&gt;文件    列表的内容追加到文件aa.txt的末尾</code></pre>
</li>
<li><p>echo        </p>
<pre><code>echo 要显示的内容&gt;&gt;存储内容的文件    将要显示的内容，存储到文件中
echo 变量    显示变量的值</code></pre>
</li>
<li><p>ln软链接</p>
<pre><code>ln -s[原文件][目标问价]    给原文件创建一个软链接，软链接存放在目标文件目录</code></pre>
</li>
<li><p>history 查看所敲命令历史</p>
</li>
</ol>
<hr>
<h3 id="vi编辑器的使用"><a href="#vi编辑器的使用" class="headerlink" title="vi编辑器的使用"></a>vi编辑器的使用</h3><h5 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h5><pre><code>yy    复制光标当前一行
y数字y    复制一段(从第几行到第几行)
p    箭头移动到目的行进行粘贴
u    撤销上一步
dd    删除光标当前行
d数字d    删除光标(含)后多少行
x    删除一个字母，相当于del
X    删除一个字母，相当于Backspace
yw    复制一个词
dw    删除一个词
shift + ^    移动到行头
shift + $    移动到行尾 
1 + shift + g    移动到页头，数字
shift + g    移动到页尾
数字N + shift + g    移动到目标行</code></pre>
<h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><pre><code>进入编辑模式
    1.    i    当前光标前
    2.    a    当前光标后
    3.    o    当前光标下一行
退出编辑模式
    ESC</code></pre>
<h5 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h5><pre><code>    w    保存    
    q    退出
    !    感叹号强制执行
/    查找，/被查找词，n是查找下一个，shift + n是往上查找
?    查找，？被查找词，n是查找上一个，shift + n是查找下一个</code></pre>
<h5 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h5><ol>
<li><p>date 显示当前时间</p>
<pre><code> date
 date +%Y-%m-%d
 date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></pre>
</li>
<li><p>date 显示非当前时间</p>
<pre><code> date -d &#39;next day&#39;
     date -d &quot;yesterday&quot;
     date -d &quot;next week&quot;
     date -d &quot;next monday&quot;
     date -d &quot;1 days ago&quot; -- 显示前一天日期
     date -d yesterday +%Y%m%d 显示前一天日期
     date -d next day +%Y%m-%d 显示明天日期</code></pre>
</li>
<li><p>date 设置系统时间</p>
<pre><code> date -s &quot;2019-01-14 22:07:25&quot;</code></pre>
</li>
<li><p>cal 查看日历</p>
<pre><code> cal
 cal 2019 2019年日历
 cal -3 最近3个月</code></pre>
</li>
</ol>
<hr>
<h5 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h5><ol>
<li><p>groupadd 新增组</p>
<pre><code> groupadd 组名</code></pre>
</li>
<li><p>groupdel 删除组</p>
<pre><code> groupdel 组名</code></pre>
</li>
<li><p>groupmod 修改组</p>
<pre><code> groupmod -n 新组名 老祖名</code></pre>
</li>
<li><p>cat/etc/group 查看创建了哪些分组</p>
</li>
<li><p>usermod 修改用户组</p>
<pre><code> usermod -g 用户名 用户组        </code></pre>
</li>
</ol>
<hr>
<h5 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h5><blockquote>
<p>-rw-r–r–. 1 root root    0 1月  16 21:05 duanyu.txt</p>
<p>drwxr-xr-x. 2 root root 4096 1月  16 21:05 gaibang</p>
</blockquote>
<pre><code>第一位： - 表示文件
        d 文件夹
第2-4位：
        用户主的权限
        r 读
        w 写
        x 执行
        - 表示没权限
第5-7位：
        用户组的权限
        r 读
        w 写
        x 执行
        - 表示没权限
第8-10位：
        其他权限
        r 读
        w 写
        x 执行
        - 表示没权限
第11位：
        链接数(未知)
第12位：
        文件拥有者
第13位：
        用户组
第14位：
        创建时间
第15位：
        文件名称</code></pre>
<h5 id="chomod-改变权限"><a href="#chomod-改变权限" class="headerlink" title="chomod 改变权限"></a>chomod 改变权限</h5><pre><code>chmod u+x demo.txt    //用户
chmod g-w demo.txt    //用户组
chmod o+w demo.txt    //其它
chmod a+w demo.txt    //所有

1：具有权限 0：没有权限
r w x
1 1 1 = 7
0 0 0 = 0
1 0 0 = 4
0 1 0 = 2
0 0 1 = 1

chmod 777 demo.txt (用户、用户组、其它都具有可读可写可执行的权限)</code></pre>
<h5 id="chown-改变所有者"><a href="#chown-改变所有者" class="headerlink" title="chown 改变所有者"></a>chown 改变所有者</h5><pre><code>chown [最终用户][文件或目录]
chown root jiumozhi.txt</code></pre>
<h5 id="chgrp-改变所属组"><a href="#chgrp-改变所属组" class="headerlink" title="chgrp 改变所属组"></a>chgrp 改变所属组</h5><pre><code>chgrp root yijinjing.txt

同时改变拥有者 和 拥有者 的组：

chown atguigu:atguigu yijinjing.txt</code></pre>
<h3 id="磁盘分区类"><a href="#磁盘分区类" class="headerlink" title="磁盘分区类"></a>磁盘分区类</h3><h5 id="fdisk-查看分区"><a href="#fdisk-查看分区" class="headerlink" title="fdisk 查看分区"></a>fdisk 查看分区</h5><pre><code>fdisk -l   功能：查看磁盘分区详情(只有root用户)</code></pre>
<h5 id="df-查看硬盘"><a href="#df-查看硬盘" class="headerlink" title="df 查看硬盘"></a>df 查看硬盘</h5><pre><code>df -h</code></pre>
<h5 id="mon"><a href="#mon" class="headerlink" title="mon"></a>mon</h5><hr>
<h5 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h5><pre><code>    fdisk 查看分区
        fdisk -l 查看磁盘分区详情
        注意：root用户
    df    查看硬盘
        df -h
    mount/umount 挂载/卸载</code></pre>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2019/06/01/Servlet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul>
<li>Servlet 3.0<ul>
<li>好处：<ul>
<li>支持注解配置，可以不需要 web.xml</li>
</ul>
</li>
<li>步骤：<ol>
<li>创建 JavaEE 项目，选择 Servlet 的版本 3.0 以上，可以不创建 web.xml</li>
<li>定义一个类，实现Servlet 接口</li>
<li>复写方法</li>
<li>在类上使用 <code>@WebServlet</code>注解，进行配置<ul>
<li><code>@WebServlet(&quot;资源路径&quot;)</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="IDEA-和-Tomcat-的相关配置"><a href="#IDEA-和-Tomcat-的相关配置" class="headerlink" title="IDEA 和 Tomcat 的相关配置"></a>IDEA 和 Tomcat 的相关配置</h5><ol>
<li><p>IDEA 会为 每一个 tomcat 部署的项目单独建立一份配置文件</p>
<ul>
<li><p>查看控制台的log : Using CATALINA_BASE :</p>
<p>“C:\User\Administracor.IntelliJidea2018.3\system\tomcat_demo1”</p>
</li>
</ul>
</li>
<li><p>工作空间目录 和 Tomcat 部署的web项目<br>2.1. Tomcat 真正访问的是 “Tomcat部署的web项目”，“Tomcat部署的web项目”对应着 “工作空间项目” “web 目录下的资源”</p>
<p>2.2. src 代码变异后放到web项目下的 class 目录下</p>
<p>2.3 WEB-INF 目录下的资源不能被浏览器直接访问</p>
</li>
<li><p>断点调试 ：使用 Debug 启动</p>
</li>
</ol>
<h5 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h5><ol start="0">
<li><p>判断请求方式 （get/post）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String method = req.getMethod();</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol>
<li><p>获取数据</p>
<pre class="mermaid">      graph BT
    B[GenericServlet `抽象类`] -->|实现| A[Servlet `接口`]
    C[HttpServlet `抽象类`] -->|继承| B</pre>




</li>
</ol>
<p>   ​    </p>
<ul>
<li><p>GenericServlet<br>实现了 <code>Servlet</code> 接口，将 <code>Servelt</code>接口中的其它方法做了默认空实现，只将 <code>service()</code>方法作为抽象</p>
<ul>
<li>将来定义 Servlet 类是，可以继承 GerericServlet ，实现 service() 即可</li>
</ul>
</li>
<li><p>HttpServlet</p>
<ul>
<li>对 HTTP 协议的一种封装，简化操作</li>
</ul>
<ol>
<li>定义类继承 HttpServlet</li>
<li>复写 <code>doGet()</code> 、<code>doPost()</code> 方法</li>
</ol>
</li>
<li><p><strong>推荐使用继承HttpServlet</strong></p>
</li>
</ul>
<h5 id="Servlet-的相关配置"><a href="#Servlet-的相关配置" class="headerlink" title="Servlet 的相关配置"></a>Servlet 的相关配置</h5><pre><code>  1. **urlpartten** : Servlet 访问路径
  * 一个 `servlet`可以定义多个访问路径 `@WebServlet(&#123;&quot;dd&quot;,&quot;dd4&quot;&#125;)`
  * 路径定义规则
    * `/xxx`
    * `/xxx/xxx` ， 目录结构
      * `@WebServlet(&quot;/user/demo&quot;)`
      * `@WebServlet(&quot;/user/*&quot;)` ： `*`代表通配符
    * `*.do`
      * `@WebServlet(&quot;*.do&quot;)` ,`*`代表通配符,`do`是随便定义的一个后缀名，随便都可以</code></pre>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul>
<li><p>概念 ： Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li><p>传输协议 ： 定义了，客户端和服务器端传输 ，文件形式</p>
<pre class="mermaid">    graph LR
    A((客户端)) -->|"请求-请求消息"| B[服务器端]
    B -->|"响应-响应消息"| A</pre>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>HTTP协议的特点：</p>
<ol>
<li><p>基于 TCP/IP 的高级协议</p>
</li>
<li><p>默认端口号是：80</p>
<p><a href="http://www.baidu.com/">http://www.baidu.com:80</a></p>
</li>
<li><p>基于请求/响应模型的：一次请求对应一次响应</p>
</li>
<li><p>无状态的：每次请求之间相互独立，不能交互数据</p>
</li>
</ol>
</li>
<li><p>历史版本：</p>
<ul>
<li>1.0 ：每一次请求响应都会建立新的连接</li>
<li>1.1 ：复用连接</li>
</ul>
</li>
<li><p>请求消息数据格式</p>
<ol>
<li><p>请求行<br>请求方式 请求url 请求协议/版本</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/login.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>请求方式 ：<ul>
<li>HTTP协议有7种请求方式，常用的有2种<ul>
<li>GET : <ol>
<li>请求参数在<strong>请求行</strong>中，在url后</li>
<li>请求的 url 是由限制的</li>
<li>不太安全</li>
</ol>
</li>
<li>POST : <ol>
<li>请求参数在<strong>请求体</strong>中</li>
<li>请求的url长度是没有限制的</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头</p>
<blockquote>
<p>请求头名称：请求头值</p>
</blockquote>
<ul>
<li>常见的请求头 ：<ol>
<li><strong>User-Agent</strong> ：浏览器告诉服务器，我访问你使用的浏览器的版本信息<ul>
<li>可以在服务器端获取该头的浏览器信息，解决浏览器的兼容问题</li>
</ul>
</li>
<li><strong>Referer</strong>: <a href="http://localhost:8080/ddd/login.html">http://localhost:8080/ddd/login.html</a><ul>
<li>告诉服务器，我（当前请求）从哪里来？<ul>
<li>作用：<ol>
<li>防盗链</li>
<li>统计工作 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>请求空行</p>
<blockquote>
<p>空行 # 做分隔作用</p>
<p>就是用于分隔post请求的请求头和请求体的</p>
</blockquote>
</li>
<li><p>请求体 （正文）</p>
<blockquote>
<p>封装post请求消息的请求体的</p>
<p>请求内容，表单提交的参数</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>字符串格式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /login.html HTTP/1.1  # 请求行</span><br><span class="line">Host: localhost:8080	# 请求头</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://localhost:8080/ddd/login.html</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">If-Modified-Since: Wed, 22 May 2019 01:32:12 GMT</span><br><span class="line">If-None-Match: W/&quot;265-1558488732253&quot;</span><br><span class="line">		# 请求空行，就是空行</span><br><span class="line">username=zhangsan</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li>响应消息数据格式</li>
</ul>
<p>1. </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 问题</title>
    <url>/2019/01/17/ubuntu%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="ubuntu-依赖问题"><a href="#ubuntu-依赖问题" class="headerlink" title="ubuntu 依赖问题"></a>ubuntu 依赖问题</h5><pre><code>    sudo apt-get update # 更新
    sudo apt-get -f install # 解决依赖问题
    sudo dpkg -i xxx.deb # 重新安装</code></pre>
<h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><pre><code>    先找到软件的名称：whereis,which,find,grep 都可以
    可以直接使用 dpkg 命令进行卸载，这叫做谁污染谁治理；
    dpkg -l |grep xxx
    # xxx 就是安装的软件名

    找到之后，使用下面的方法进行卸载
    sudo dpkg --purge xxxx
    rm -rf ~/.local/share/xxxx

    这样的话就彻底卸载了</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>maven基础</title>
    <url>/2019/08/11/maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个项目一般可以分为：</p>
<ul>
<li>核心代码部分</li>
<li>配置文件部分</li>
<li>测试代码部分</li>
<li>测试配置部分</li>
</ul>
<h4 id="Maven-Java-项目标准目录结构"><a href="#Maven-Java-项目标准目录结构" class="headerlink" title="Maven Java 项目标准目录结构"></a>Maven Java 项目标准目录结构</h4><ul>
<li><p>核心代码部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src/main/java 目录</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src/main/resources 目录</span><br></pre></td></tr></table></figure></li>
<li><p>测试代码部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src/test/java 目录</span><br></pre></td></tr></table></figure></li>
<li><p>测试配置部分</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">src<span class="regexp">/test/</span>resources </span><br></pre></td></tr></table></figure></li>
<li><p>页面资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src/main/webapp 里面包含 js,css,图片等等</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h4><ul>
<li><p><strong>清除项目编译信息</strong> ： <code>mvn clean</code></p>
</li>
<li><p><strong>编译</strong>  ：<code>mvn compile</code></p>
</li>
<li><p><strong>测试</strong> ： <code>mvn test</code></p>
</li>
<li><p><strong>打包</strong> ： <code>mvn package</code></p>
</li>
<li><p><strong>安装</strong> ： <code>mvn install</code></p>
</li>
<li><p><strong>发布</strong> ： <code>mvn deploy</code></p>
</li>
</ul>
<h4 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h4><blockquote>
<p><code>mvn clean</code> 清除生命周期</p>
</blockquote>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><blockquote>
<ul>
<li><strong>编译</strong>  ：<code>mvn compile</code></li>
<li><strong>测试</strong> ： <code>mvn test</code></li>
<li><strong>打包</strong> ： <code>mvn package</code></li>
<li><strong>安装</strong> ： <code>mvn install</code></li>
<li><strong>发布</strong> ： <code>mvn deploy</code></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2019/08/17/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java代码 在计算机中 经历的阶段：三个阶段</p>
]]></content>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>廖雪峰 python</title>
    <url>/2019/05/04/%E5%BB%96%E9%9B%AA%E5%B3%B0python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.baidu.com/" title="百度">https://www.baidu.com/</a></p>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><blockquote>
<p>​    pyhton 为了简化，允许使用  r ‘’表示 ‘’ 内部的字符默认不转义</p>
</blockquote>
<p>如果 字符串内有很多换行，用 \n 写在一行里不好阅读，为了简化，Python 允许用 ‘’’…’’’ 表示多行内容</p>
<h4 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h4><blockquote>
<p>在最新的python 3 中,字符串十一Unicode编码的</p>
</blockquote>
<ul>
<li><p>单个字符的函数</p>
<blockquote>
<p>ord()     # 获取字符的整数表示</p>
<p>chr()    # 将编码转换为对应的字符</p>
</blockquote>
</li>
<li><p>如果知道了字符的整数编码，可以用十六进制这么写</p>
<blockquote>
<p>‘\u4e2d\u6587’</p>
<p>‘中文’</p>
<p>这两种写法是等价的;</p>
</blockquote>
</li>
<li><p>以Unicode 表示的 str 通过 encode() 方法可以编码为 指定的 bytes</p>
</li>
<li><p>要把 bytes 转化为 str ，就需要用 decode()方法;</p>
</li>
<li><p>如果 byes 中只有一小部分无效的字节，可以传入 errors=’ignore’忽略错误的字节</p>
</li>
<li><p>计算 str 包含 多少个字符，可以用 len()函数</p>
</li>
<li><p>len() 是计算 str 的字符数，如果换成 bytes,len()函数就计算字节数</p>
</li>
<li><p>% 就是用来格式化字符串的</p>
<table>
<thead>
<tr>
<th>#### 占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%X</td>
<td>十六进制整数</td>
</tr>
</tbody></table>
</li>
<li><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数<br>`</p>
<pre><code> print(&#39;%2d-%02d&#39; % (3,1))
 3-01
print(&#39;%.2f&#39; % 3.1415926)
3.14</code></pre>
<p>`</p>
</li>
<li><p>另一种格式化字符串的方法是使用字符串的 format() 方法，他会用传入的参数依次替换字符串内的占位符{0}、{1}……</p>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ol>
<li><p>python 内置的一种数据类型是列表：list</p>
</li>
<li><p>list 是一种有序的集合，可以随时添加和删除其中的元素</p>
</li>
<li><p>len() 可以获取 list 元素的个数</p>
</li>
<li><p>用索引来访问 list 么一个位置的元素，记得索引是从0 开始的</p>
</li>
<li><p>list 是一个可变的有序表，可以往list中追加元素到末尾<br><code>classmates.append(&#39;Adam&#39;)</code></p>
</li>
<li><p>把元素插入到指定的位置，比如索引号为1的位置：<br><code>calssmates.insert(1,&#39;Jack&#39;)</code></p>
</li>
<li><p>要删除list末尾的元素，用 <code>pop()</code> 方法<br><code>classmates.pop()</code></p>
</li>
<li><p>要删除指定位置的元素，用 <code>pop(i)</code> 方法，其中 i 是索引位置<br><code>classmates.pop(1)</code></p>
</li>
<li><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：<br><code>classmates[1] = &#39;Sarah&#39;</code></p>
</li>
<li><p>list 元素里面的元素数据类型也可以不相同<br><code>L = [&#39;apple&#39;,10,True]</code></p>
</li>
<li><p>list 元素也可以是另一个list<br><code>s - [&#39;python&#39;,&#39;java&#39;,[&#39;asp&#39;,&#39;php&#39;],&#39;schema&#39;]</code><br><code>len(s)</code><br><code>4</code><br><code>s[2][1]</code></p>
</li>
</ol>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ol>
<li><p>另一种有序列表叫元祖：tuple</p>
</li>
<li><p>tuple 与 list 非常相似，但是 tuple 一旦初始化就不能修改</p>
</li>
<li><p>tuple 的陷阱：当你定义一个 tuple 时，在定义的时候， tuple 的元素就必须被确定下来<br><code>t= (1,2)</code><br><code>t</code><br><code>(1,2)</code></p>
</li>
<li><p>如果要定义一个空的tuple,可以写成 ()<br><code>t = 0</code><br><code>t</code><br><code>0</code></p>
</li>
<li><p>但是，要定义一个只有 1 个元素的 tuple ，如果这么定义:<br><code>t = (1)</code><br><code>t</code><br><code>1</code><br>定义的不是tuple，是 1 这个数！这是因为 () 即可以表示 tuple ，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定这种情况下，按照小括号计算，计算结果自然是1；<br>所以，只有 1 个元素 的 tuple 定义的时候必须加一个逗号，，来消除歧义<br>t = (1,)<br>t<br>(1,)</p>
</li>
<li><p>“可变的”tuple</p>
<p><code>t = (&#39;a&#39;,&#39;b&#39;,[&#39;A&#39;,&#39;B&#39;])</code></p>
<p><code>t[2][0] = &#39;X&#39;</code></p>
<p><code>t[2][1] = &#39;Y&#39;</code></p>
<p><code>t</code></p>
<p><code>(&#39;a&#39;,&#39;b&#39;,[&#39;X&#39;,&#39;Y&#39;])</code></p>
<ul>
<li>注意：tuple 的元素确实变了，但其实变得不是tuple的元素，而是list的元素</li>
<li>tuple 所谓的 “不变” 是说，tuple 的每个元素，只想永远不变。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>//404.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="index/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20200921222923.png" alt="老友记-瑞秋"></p>
<p><img data-src="index/p2021994737.webp" alt="梁咏琪"></p>
<p><img data-src="index/p1931021849.webp" alt="《逃学威龙三》"></p>
<p><img data-src="index/p2573917030.webp" alt="《逃学威龙》"></p>
<p><img data-src="index/p2573917029.webp" alt="《逃学威龙》"></p>
<p><img data-src="index/p2549919514.webp" alt="《新精武门》"></p>
<p><img data-src="index/p2100890063.webp" alt="《与龙共舞》"></p>
<p><img data-src="index/p2622284989.webp" alt="《绝代双骄》"></p>
<p><img data-src="index/p2494532278.webp" alt="《与龙共舞》"></p>
<p><img data-src="index/p2317446206.webp" alt="《逃学威龙》"></p>
<p><img data-src="index/p2317446207.webp" alt="《逃学威龙》"></p>
]]></content>
  </entry>
  <entry>
    <title>归档</title>
    <url>/archives/index.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>日程表</title>
    <url>/schedule/index.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>站点地图</title>
    <url>/sitemap/index.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
</search>
