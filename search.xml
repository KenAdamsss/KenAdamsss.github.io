<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Response笔记]]></title>
    <url>%2F2019%2F06%2F02%2FResponse%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTTP协议：响应消息 Response对象 ServletContext对象 HTTP协议： 请求消息：客户端发送给服务器端的数据 数据格式： 请求行 请求头 请求空行 请求体 响应消息：服务器端发送给客户端的数据 数据格式： 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码都是3位数字 分类： 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。 代表： 404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头：​ 1. 格式：头名称： 值​ 2. 常见的响应头：​ 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式​ 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据​ * 值：​ * in-line:默认值,在当前页面内打开​ * attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体:传输的数据 响应字符串格式 123456789101112131415HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径​ ​ 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a);案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同]]></content>
      <categories>
        <category>Java</category>
        <category>Request</category>
        <category>Respons</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Request</tag>
        <tag>Respons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request和Respons]]></title>
    <url>%2F2019%2F06%2F02%2FRequest%E5%92%8CRespons%2F</url>
    <content type="text"><![CDATA[Requestrequest对象 和 response 对象的原理 request 和 response 对象是由服务器创建的。我们只是来使用它们 request 是来 获取请求消息 ， response 对象是来设置响应消息 浏览器访问服务器过程 tomcat 服务器会根据请求 url 中资源路径，创建对应的 ServletDemo1 的 对象。 tomcat 服务器，会创建 request 和 response 对象，request 对象中封装请求消息数据。 tomcat 将 request 和 response 两个对象传递给 service() 方法，并且调用 service 方法。 我们可以通过 request 对象获取请求消息数据，通过 response 对象设置响应消息数据。 服务器在给浏览器做出响应之前，会从 response 对象中拿程序员设置的响应消息数据。 request 对象继承体系结构 ：graph BT B[HttpServletRequest `接口`] -->|继承| A[ServletRequest `接口`] C[org.apache.catalina.connector.RequestFacade `类` *tomact编写* ] -->|实现| B request 功能 获取请求消息数据 获取请求行数据 GET /day14/demo1?name=zhangsan HTTP/1.1 方法 ： 获取请求方式 ：GET String getMethod() ()*获取虚拟目录** ：/day14 String getContextPath() 获取Servlet路径 ：/demo1 String getServletPath() 获取get方式的请求参数 ：name=zhangsan String getQueryString() ()*获取请求的URI** : /day14/demo1 String getRequestURI() : /day14/demo1 StringBuffer getRequestURL() : http://localhost/day4/demo1 URL : 统一资源定位符 ：http://localhost/day4/demo1 URI : 统一资源标识符 ：/day14/demo1 表示的范围更大 获取协议及版本 ： HTTP/1.1 String getProtocol() 获取客户机的 IP 地址 ： String getRemoteAddr() 获取请求头数据 方法 () *String getHeader(String name)** : 通过请求头的名称获取请求头的值 Enumeration getHeaderNames() : 获取所有的请求头的名称 获取请求体数据 请求体 ：只有 POST请求方式，才有请求体，在请求体中封装了post请求的请求参数 步骤： 获取流对象 BufferedReader getReader() : 获取字节输入流，只能操作字符数据 ServletInputStream getInputStream() : 获取字节输入流，可以操作所有类型数据 在文件上传知识点后 再从流对象中拿数据 其他功能 : 获取请求参数 通用方式 String getParameter(String name) : 根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name) : 根据参数名称获取参数值 habby=xx&amp;habby=game Enumeration getParameterNames() : 获取所有请求参数的名称 Map&lt;String,String[]&gt; getParameterMap() : 获取所有参数的map集合 * 中文乱码问题： * get方式 ： Tomcat 8 以后已经解决 * post 方式 ：在获取请求参数前，设置编码方式 ：`req.setCharacterEncoding(&quot;utf-8&quot;);` 请求转发 ：一种在服务器内部的资源跳转方式 步骤 ： 通过 request 对象获取请求转发器对象 ： RequestDispatcher getRequestDispatcher(String path) 使用 RequestDispatcher 对象来进行转发 ：foward(ServletRequest request, ServletResponse response) 特点 ： 浏览器地址栏路径不会发生变化 只能转发到当前服务器内部资源中 转发只是一次请求 共享数据： 域对象 ：一个有作用范围的对象，可以在范围内共享数据 request域 ：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法 ： void setAttribute(String name, Object obj) ：存储数据 Object getAttribute(String name) : 通过建获取值 void removeAttribute(String name) : 通过键移除键值对 获取 ServletContext ServletContext getServletContext() 案例 ：用户登录 用户登录案例需求 ： 编写 login.html 登录页面username &amp; password 两个输入框 使用 Druid 数据库连接池技术，操作 mysql ，day14 数据库中的 user 表 使用 jdbcTemplate技术封装 JDBC 登录成功跳转 SuccessServlet展示：登录成功！用户名，欢迎您 登录失败跳转 FailServlet 展示 ：登录失败，用户名或密码错误！ 分析 开发步骤 创建项目，导入HTML，配置文件，jar包 创建数据库环境 123456mysql&gt; create database day14;mysql&gt; use day14;mysql&gt; create table user( -&gt; id int primary key auto_increment, -&gt; username varchar(32) unique not null, -&gt; password varchar(32) not null); 创建包 cn.itcast.domain，创建类User 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast.domain;/** * 用户的实体类 */public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 创建包 cn.itcast.util，创建类JDBCUtil 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * JDBC 工具类 使用 Durid 连接池 */public class JDBCUtil &#123; private static DataSource ds; static &#123; try &#123; // 1. 加载配置文件 Properties pro = new Properties(); // 使用 ClassLoader 加载配置文件，获取字节输入流 InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("druid.properties"); pro.load(is); // 2. 初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接 Connection 对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; 创建包 cn.itcast.dao，创建类UserDao，提供 login() 12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.Dao;import cn.itcast.domain.User;import cn.itcast.util.JDBCUtil;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * 操作数据库中User表的类 */public class UserDao &#123; // 声明JDBCTemplate 对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtil.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user 包含用户全部数据,没有查询到，返回 Null */ public User login(User loginUser)&#123; try &#123; // 1.编写sql String sql = "select * from user where username = ? and password = ?"; // 2.编写query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 编写 cn.itcast.web.servlet.LoginServlet类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.itcast.web.servlet;import cn.itcast.Dao.UserDao;import cn.itcast.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet("/loginServlet")public class LoginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.设置编码 request.setCharacterEncoding("utf-8"); // 2.获取请求参数 ： 用户名密码 String username = request.getParameter("username"); String password = request.getParameter("password"); // 3. 封装 User 对象 ：将用户名密码封装 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); // 4.调用UserDao的 login 方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); if (user == null) &#123; // 登录失败，转发到 FailServlet request.getRequestDispatcher("/failServlet").forward(request,response); &#125; else &#123; // 登录成功 // 存储 request.setAttribute("user",user); // 转发到 SuccessServlet request.getRequestDispatcher("/successServlet").forward(request,response); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; login.html 中 from 表单的action路径的写法 ： 虚拟目录 + Servlet的资源路径 编写 cn.itcast.web.servlet.FailServlet类 123456789101112131415161718192021222324package cn.itcast.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet("/failServlet")public class FailServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 在页面上打印内容 // 设置编码 response.setContentType("text/html;charset=utf-8"); // 输出 response.getWriter().write("登录失败，用户名或密码错误"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; 编写 cn.itcast.web.servlet.SuccessServlet类 123456789101112131415161718192021222324252627package cn.itcast.web.servlet;import cn.itcast.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet("/successServlet")public class SuccessServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取request域中共享的user对象存储内容 User user = (User) request.getAttribute("user"); if (user != null) &#123; response.setContentType("text/html;charset=utf-8"); response.getWriter().write("登录成功，" + user.getUsername() + "，欢迎您！"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; BeanUtils工具类，简化数据封装 用于封装 JavaBean的 JavaBean : 标准的Java类 要求 ： 类必须被public修饰 必须提供 空参 的构造器 成员变量必须使用 private 修饰 提供公共 setter 和 getter 方法 概念 ： 成员变量 ： 属性 ：setter 和 getter 方法截取后的产物 ​ 例如 ： getUsername() –&gt; Username – &gt; username 方法 ： setProperty() : 设置属性值 getProperty() : populate(Object obj,Map map) : 将 map 集合中的健值对信息，封装到对应的 JavaBean 对象中]]></content>
      <categories>
        <category>Java</category>
        <category>Request</category>
        <category>Respons</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Request</tag>
        <tag>Respons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F06%2F01%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet Servlet 3.0 好处： 支持注解配置，可以不需要 web.xml 步骤： 创建 JavaEE 项目，选择 Servlet 的版本 3.0 以上，可以不创建 web.xml 定义一个类，实现Servlet 接口 复写方法 在类上使用 @WebServlet注解，进行配置 @WebServlet(&quot;资源路径&quot;) IDEA 和 Tomcat 的相关配置 IDEA 会为 每一个 tomcat 部署的项目单独建立一份配置文件 查看控制台的log : Using CATALINA_BASE : “C:\User\Administracor.IntelliJidea2018.3\system\tomcat_demo1” 工作空间目录 和 Tomcat 部署的web项目2.1. Tomcat 真正访问的是 “Tomcat部署的web项目”，“Tomcat部署的web项目”对应着 “工作空间项目” “web 目录下的资源” 2.2. src 代码变异后放到web项目下的 class 目录下 2.3 WEB-INF 目录下的资源不能被浏览器直接访问 断点调试 ：使用 Debug 启动 service() 方法 判断请求方式 （get/post） 123456String method = req.getMethod();if ("GET".equals(method)) &#123; ....&#125; else if ("POST".equals(method)) &#123; ...&#125; 获取数据 graph BT B[GenericServlet `抽象类`] -->|实现| A[Servlet `接口`] C[HttpServlet `抽象类`] -->|继承| B ​ GenericServlet实现了 Servlet 接口，将 Servelt接口中的其它方法做了默认空实现，只将 service()方法作为抽象 将来定义 Servlet 类是，可以继承 GerericServlet ，实现 service() 即可 HttpServlet 对 HTTP 协议的一种封装，简化操作 定义类继承 HttpServlet 复写 doGet() 、doPost() 方法 推荐使用继承HttpServlet Servlet 的相关配置1. **urlpartten** : Servlet 访问路径 * 一个 `servlet`可以定义多个访问路径 `@WebServlet({&quot;dd&quot;,&quot;dd4&quot;})` * 路径定义规则 * `/xxx` * `/xxx/xxx` ， 目录结构 * `@WebServlet(&quot;/user/demo&quot;)` * `@WebServlet(&quot;/user/*&quot;)` ： `*`代表通配符 * `*.do` * `@WebServlet(&quot;*.do&quot;)` ,`*`代表通配符,`do`是随便定义的一个后缀名，随便都可以HTTP 概念 ： Hyper Text Transfer Protocol 超文本传输协议 传输协议 ： 定义了，客户端和服务器端传输 ，文件形式 graph LR A((客户端)) -->|"请求-请求消息"| B[服务器端] B -->|"响应-响应消息"| A HTTP协议的特点： 基于 TCP/IP 的高级协议 默认端口号是：80 http://www.baidu.com:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0 ：每一次请求响应都会建立新的连接 1.1 ：复用连接 请求消息数据格式 请求行请求方式 请求url 请求协议/版本 1GET /login.html HTTP/1.1 请求方式 ： HTTP协议有7种请求方式，常用的有2种 GET : 请求参数在请求行中，在url后 请求的 url 是由限制的 不太安全 POST : 请求参数在请求体中 请求的url长度是没有限制的 相对安全 请求头 请求头名称：请求头值 常见的请求头 ： User-Agent ：浏览器告诉服务器，我访问你使用的浏览器的版本信息 可以在服务器端获取该头的浏览器信息，解决浏览器的兼容问题 Referer: http://localhost:8080/ddd/login.html 告诉服务器，我（当前请求）从哪里来？ 作用： 防盗链 统计工作 请求空行 空行 # 做分隔作用 就是用于分隔post请求的请求头和请求体的 请求体 （正文） 封装post请求消息的请求体的 请求内容，表单提交的参数 字符串格式 12345678910111213GET /login.html HTTP/1.1 # 请求行Host: localhost:8080 # 请求头User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost:8080/ddd/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1If-Modified-Since: Wed, 22 May 2019 01:32:12 GMTIf-None-Match: W/"265-1558488732253" # 请求空行，就是空行username=zhangsan 响应消息数据格式 1.]]></content>
      <categories>
        <category>Java</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop]]></title>
    <url>%2F2019%2F05%2F04%2FHadoop%2F</url>
    <content type="text"><![CDATA[一、从Hadoop框架讨论大数据生态1.1 Hadoop是什么 Hadoop 是一个 Apache 基金会所开发的分布式系统基础架构 主要解决，海量数据的存储（HDFS） 和 海量数据的分析计算 （MapReduce）问题 广义上说，Hadoop 通常是指一个更广泛的概念 - Hadoop 生态圈 1.2 Hadoop 发展历史1.3 Hadoop 三大发行版本Apache、Cloudera、Hortonworks 1.4 Hadoop 的优势 高可靠性因为Hadoop假设计算元素和存储会出现故障，因为它维护多个工作数据副本，在出现故障时可以对失败的节点重新分布处理 高扩展性在集群分配任务数据，可方便的扩展数以千计的节点 高效性在 MapReduce 的思想下，Hadoop 是并行工作的，以加快任务处理速度 高容错性自动保存多份副本数据，并且能够自动将失败的任务重新分配 1.5 Hadoop 组成概述 Hadoop HDFS : 一个高可靠、高吞吐量的分布式文件系统 Hadoop MapReduce : 一个分布式的离线并行计算框架 Hadoop YARN : 作业调度与集群资源管理的框架 Hadoop Common : 支持其他模块的工具模块 1.5.1 HDFS 架构概述 NameNode (nn) : 存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的 DataNode 等 DataNode （dn）` : 在本地文件系统存储文件块数据，以及块数据的校验和 SecondaryNameNode (2nn) : 用来监控 HDFS 状态的辅助后台程序，每隔一段时间获取 HDFS 元数据的快照。 1.5.2 YARN 架构概述 ResourceManager (rm) :处理客户端请求、启动/监控 ApplicationMaster、监控 NodeManager 、资源分配与调度 NodeManager (nm) :单个节点上的资源管理、处理来自 ResourceManager 的命令、处理来自 ApplicationMaster 的命令 ApplicationMaster :数据切分、为应用程序申请资源，并分配给内部任务、任务监控与容错 Container :对任务运行环境的抽象，封装了 CPU 、内存等多位资源以及环境变量、启动命令等任务运行相关的信息 1.5.3 MapReduce 架构概述MapReduce 将计算过程分成两个阶段 ： Map 和 Reduce Map 阶段并行处理输入数据 Reduce 阶段对 Map 结果进行汇总 1.6 大数据技术生态体系1.7 推荐系统框架图二、Hadoop运行环境搭建2.1 虚拟机网络模式设置为 NAT2.1 克隆虚拟机2.3 修改为静态 IP2.4 修改主机名2.5 关闭防火墙123456789101112131415161718192021222324252627282930# 修改 克隆来的机器的 eth0vi /etc/udev/rules.d/70-persistent-net.rules 删除eth0 升级eht1为eth0 复制物理ip地址# 修改 vi /etc/sysconfig/network-scripts/ifcfg-eth0 粘贴复制的物理ip地址 修改 IPADDR # 查看主机名hostname# 修改主机名vi /etc/sysconfig/network# 配置 hosts 文件vi /etc/hosts 192.168.188.100 hadoop100 192.168.188.101 hadoop101 192.168.188.102 hadoop102 ...------------------------------------------sync reboot# 关闭防火墙# 查看防火墙chkconfig iptables --list 2.6 在 opt 目录下创建文件使用 atguigu 用户在 /opt 目录下创建 module software 目录 module ： 安装目录 software ：接收从window 传输过来的安装包 123456789# 修改 atguigu 用户权限vi /etc/sudoers# atguigu 使用 sudo 创建 目录sudo mkdir modulesudo mkdir module# 修改用户所有者 和 用户组sudo chown atguigu:atguigu module/ software/ 2.7 安装 jdk 卸载现有的 jdk 用 filezilla 工具将 jdk 、Hadoop-2.7.2.tar.gz 导入到 opt 目录下面的 software 文件夹下 在 linux 系统下的 opt 目录中查看软件包是否导入成功 解压 jdk 到 /opt/module 目录下 1tar -zxvf jdk-7u79-linux-x64.gz -C /opt/module/ 配置 jdk 环境变量 12345678910sudo vi /etc/profileShift + Go#JAVA_HOMEexport JAVA_HOME=/opt/module/jdk1.7.0_79exprot PATH=$PATH:$JAVA_HOME/binsource /etc/profile 测试 jdk 安装成功 123java或rpm -qa |grep java 2.8 安装 Hadoop 进入到 Hadoop 安装包路径下： 解压安装文件到 /opt/moudle 下面 1tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module 查看解压是否成功 配置 hadoop 中的 hadoop-env.sh Linux 系统中获取 jdk 的安装路径 修改 hadoop-env.sh 文件中 JAVA_HOME 路径 12345cd /opt/module/hadoop-2.7.2/etc/hadoopsudo vi hadoop-env.shexport JAVA_HOME=/opt/module/jdk1.7.0_79 将Hadoop添加到环境变量 获取 Hadoop 安装路径 打开 /etc/profile 文件 保存后退出 让修改后的文件生效 重启 （如果Hadoop命令不能用再重启） 12345678sudo vi /etc/profile##HADOOP_HOMEexport HADOOP_HOME=/opt/module/hadoop-2.7.2export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbinsource /etc/profile 三、Hadoop运行模式概述 官方网址 Hadoop 运行模式 本地模式（默认模式）：不需要启动单独进程，直接可以运行，测试和开发时使用 伪分布式模式 ：等同于完全分布式，只有一个节点 完全分布式模式： 多个节点一起运行 3.1 本地文件运行 Hadoop 案例3.1.1 官方 grep 案例 创建在 hadoop-2.7.2 文件下面 创建一个 input 文件夹 1mkdir input 将 hadoop 的 xml 配置文件复制到input 1cp etc/hadoop/*.xml input/ 执行share目录下的mapreduce 程序 1hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output 'dfs[a-z]+' 查看数据结果 3.1.2 官方 wordcount 案例 创建在 hadoop-2.7.2 文件下面创建一个wcinput 文件夹 1mkdir wcinput 在 wcinput 文件下创建一个 wc.input 文件 12# 随便一个文本touch wc.input 编辑 wc.input 文件 12vi wc.input# 随便写点东西 回到 hadoop 目录 /opt/module/hadoop-2.7.2 执行程序 1hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput 查看结果 3.2 伪分布式运行 Hadoop 案例3.2.1 HDFS 上运行 MapReduce 程序 分析 准备一台客户机 安装JDK 配置环境变量 安装Hadoop 配置环境变量 配置集群 启动、测试集群增、删、查 在 HDFS上 执行 wordcount 案例 执行步骤 配置集群a. 配置 ： hadoop-env.sh 123Linux 系统获取 jdk 的安装路径 修改 JAVA_HOME 路径 ​ b. 配置 ： core-site.xml 1234567891011&lt;!-- 指定 HDFS 中 NameNode 的地址 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://hadoop101:8020&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/module/hadoop-2.7.2/data/tmp&lt;/value&gt;&lt;/property&gt; c. 配置 : hdfs-site.xml 12345&lt;!-- 指定 HDFS 副本的数量 --&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt;&lt;/property&gt; 启动集群 a. 格式化 namenode (第一次启动时格式化，以后就不要总格式化) 1hdfs namenode -format b. 启动 namenode 1hadoop-daemon.sh start namenode c. 启动 datanode 1234hadoop-deamon.sh start datanode# 查看java进程jps 查看集群a. 查看是否启动成功 1jps b. 查看产生的 log 日志 12# logs 文件夹下.log 文件 c. web端查看 HDFS 文件系统 1192.168.188.101:50070 操作集群a. 在 hdfs 文件夹系统上创建一个 input 文件夹 12345678910111213`hadoop fs` (等价) `bin/hdfs dfs`# 创建 input 目录hadoop fs -mkdir -p /user/atguigu/input# 递归列出目录[atguigu@hadoop101 logs]$ hadoop fs -ls -R /drwxr-xr-x - atguigu supergroup 0 2019-05-12 13:19 /userdrwxr-xr-x - atguigu supergroup 0 2019-05-12 13:19 /user/atguigudrwxr-xr-x - atguigu supergroup 0 2019-05-12 13:19 /user/atguigu/input# 命令同上,递归列出目录hadoop fs -lsr b. 将测试文件内容上传到 文件系统上 1hadoop fs -put wcinput/wc.input /user/atguigu/input c. 查看上传的文件是否正确 1hadoop fs -lsr d. 在 hdfs 上运行 mapreduce 程序 1234hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input/ /user/atguigu/output# 查看hadoop fs -cat /user/atguigu/output/p* e. 查看输出结果 f. 将测试文件内容下载到本地 g. 删除输出结果 1hadoop fs -rmr /user/atguigu/output 3.2.2 YARN 上运行 MapReduce 程序3.2.3 修改本地临时文件存储目录3.2.4 Hadoop配置文件说明3.3 完全分布式部署 Hadoop四、Hadoop编译源码]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰 python]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%BB%96%E9%9B%AA%E5%B3%B0python%2F</url>
    <content type="text"><![CDATA[https://www.baidu.com/ 转义字符 ​ pyhton 为了简化，允许使用 r ‘’表示 ‘’ 内部的字符默认不转义 如果 字符串内有很多换行，用 \n 写在一行里不好阅读，为了简化，Python 允许用 ‘’’…’’’ 表示多行内容 Python的字符串 在最新的python 3 中,字符串十一Unicode编码的 单个字符的函数 ord() # 获取字符的整数表示 chr() # 将编码转换为对应的字符 如果知道了字符的整数编码，可以用十六进制这么写 ‘\u4e2d\u6587’ ‘中文’ 这两种写法是等价的; 以Unicode 表示的 str 通过 encode() 方法可以编码为 指定的 bytes 要把 bytes 转化为 str ，就需要用 decode()方法; 如果 byes 中只有一小部分无效的字节，可以传入 errors=’ignore’忽略错误的字节 计算 str 包含 多少个字符，可以用 len()函数 len() 是计算 str 的字符数，如果换成 bytes,len()函数就计算字节数 % 就是用来格式化字符串的 #### 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %X 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数` print(&apos;%2d-%02d&apos; % (3,1)) 3-01 print(&apos;%.2f&apos; % 3.1415926) 3.14` 另一种格式化字符串的方法是使用字符串的 format() 方法，他会用传入的参数依次替换字符串内的占位符{0}、{1}…… list python 内置的一种数据类型是列表：list list 是一种有序的集合，可以随时添加和删除其中的元素 len() 可以获取 list 元素的个数 用索引来访问 list 么一个位置的元素，记得索引是从0 开始的 list 是一个可变的有序表，可以往list中追加元素到末尾classmates.append(&#39;Adam&#39;) 把元素插入到指定的位置，比如索引号为1的位置：calssmates.insert(1,&#39;Jack&#39;) 要删除list末尾的元素，用 pop() 方法classmates.pop() 要删除指定位置的元素，用 pop(i) 方法，其中 i 是索引位置classmates.pop(1) 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：classmates[1] = &#39;Sarah&#39; list 元素里面的元素数据类型也可以不相同L = [&#39;apple&#39;,10,True] list 元素也可以是另一个lists - [&#39;python&#39;,&#39;java&#39;,[&#39;asp&#39;,&#39;php&#39;],&#39;schema&#39;]len(s)4s[2][1] tuple 另一种有序列表叫元祖：tuple tuple 与 list 非常相似，但是 tuple 一旦初始化就不能修改 tuple 的陷阱：当你定义一个 tuple 时，在定义的时候， tuple 的元素就必须被确定下来t= (1,2)t(1,2) 如果要定义一个空的tuple,可以写成 ()t = 0t0 但是，要定义一个只有 1 个元素的 tuple ，如果这么定义:t = (1)t1定义的不是tuple，是 1 这个数！这是因为 () 即可以表示 tuple ，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定这种情况下，按照小括号计算，计算结果自然是1；所以，只有 1 个元素 的 tuple 定义的时候必须加一个逗号，，来消除歧义t = (1,)t (1,) “可变的”tuple t = (&#39;a&#39;,&#39;b&#39;,[&#39;A&#39;,&#39;B&#39;]) t[2][0] = &#39;X&#39; t[2][1] = &#39;Y&#39; t (&#39;a&#39;,&#39;b&#39;,[&#39;X&#39;,&#39;Y&#39;]) 注意：tuple 的元素确实变了，但其实变得不是tuple的元素，而是list的元素 tuple 所谓的 “不变” 是说，tuple 的每个元素，只想永远不变。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进阶（二）]]></title>
    <url>%2F2019%2F01%2F17%2FLinux%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-wYgowfui"), narrow: false, autoplay: true, showlrc: false, music: { title: "Staring At You", author: "Diane Birch", url: "https://m10.music.126.net/20190123220550/1a1b7f985c56a480d71462dc75abaa81/ymusic/bb41/2a86/d5cf/41ec0c033de62d81158b5319966bb57d.mp3", pic: "http://p2.music.126.net/iiH7lL1eL37cvIPfEyRzwg==/5732853627334127.jpg?param=130y130", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 7.7 磁盘分区类7.7.1 fdisk查看分区​ 基本语法：fdisk -l 7.7.2 查看硬盘​ df -h 7.7.3 mount / umount 挂载 /卸载12挂载：mount -t iso9660 -o rw /dev/cdrom /mnt/cdrom/卸载：umnout /mnt/cdrom 7.8 搜索查找类7.8.1 find 查找文件或目录​ 基本语法： find [搜索范围] [匹配条件] ​ 案例： ​ (1) 按文件名，根据名称查找 /目录下 的 filename.txt文件 1find /home/atguigu/ -name "*.txt" ​ (2) 按拥有者，查找 /opt 目录下，用户名为 -user 的文件 ​ 1mv -t bb shaolinsi # 移动 shaolinsi 到 bb 目录内 1find tlbu/ -user atguigu ​ ​ (3) 按文件大小，在 /home 目录下查找大于200m 的文件 (+n 大于 ，-n 小于， n 等于) 12# 查找小于10 m 的文件find tlbu/ -size -10 7.8.2 grep 在文件内搜索字符串匹配的行并输出12# 查找 ll.txtls -l |grep ll.txt 7.8.3 which 文件搜索命令12# 查找 ls 可执行文件存放在哪里which ls 7.9 进程线程类7.9.1 ps查看系统中所有进程123# 查看所有进程ps -auxgrep -aux |grep 3121 7.9.2 top查看系统健康状态123456toptop -d 1 # 1秒刷新一次top -l 使top 不显示未激活的进程按 P 使用CPU 排序按 M 内存使用排序N pid排序 7.9.3 pstree 查看进程树123pstreepstree -u # 显示进程属于哪一个用户pstree -p # 显示pid 7.9.4 kill终止进程1kill -9 3863 # 关闭pid 为 3868进程 -9（强迫关闭） 7.9.5 netstat显示网络统计信息​ netstat -anp用来显示整个系统目前的网络情况，例如目前的连接、数据包传递数据、或是路由表内容 12netstat -anpnetstat -anp |grep 3897 # 显示pid 为3897 的网络情况 7.10 压缩和解压缩7.10.1 gzip/gunzip压缩123456gzip + 文件 功能描述：压缩文件，只能将文件压缩为 `*.gz` 文件 1. 只能压缩文件不能压缩目录，只能单个压缩 2. 不保留原来的文件gunzip + 文件 功能：解压缩 7.10.2 zip/unzip压缩1234# 使用 `zip` 同时压缩多个文件zip yijinjing ll.txt ss.txt# 使用 `unzip` 解压缩unzip yijinjing.zip 7.10.3 tar打包12345678910111213tar 参数 + XXX.tar.gz + 将要打包的内容 参数： -c 产生 .tar 打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包 .tar 文件压缩：tar -zcvf XXX.tar.gz n1.txt n2.txt解压：tar -zxvf XXX.tar.gz # 通过 `-C` 指定解压目录 tar -zxvf khbd.tar.gz -C ./wlmiji/ 7.11 后台服务管理类7.11.1 service 后台服务管理7.11.2 chkconfig设置后台服务的自启配置7.12 crond系统定时任务12345crontab [选项]选项： -e : 编辑 crontab 定时任务 -l : 查询 crontab 任务 -r : 删除当前用户所有的 crontab 任务 crontab -e 项目 含义 范围 第一个 “*” 一小时当中的第几分钟 0-59 第二个 “*” 一天当中的第几个小时 0-23 第三个 “*” 一个月当中的第几天 1-31 第四个 “*” 一年当中的第几个月 1-12 第无个 “*” 一周单中的星期几 0-7（0和7都代表星期日） 123crontab -e进入 crontab 编辑界面，会打开 vim 编辑你的工作。1 16 1 5 * 执行的任务(echo "hello world"&gt;&gt;/home/atguigu/t.txt) 特殊字符： 特殊字符 含义 * 代表任何时间。比如第一个”*”就代表一小时中每分钟都执行一次 , 代表不连续的时间比如”0 8,12,16 ***”命令，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 - 代表连续的时间范围比如”0 5 * * 1-6”,代表在周一到周六的凌晨5点0分执行命令 */n 代表每隔多久执行一次比如”*/10 * * * *”命令，代表每个10分钟就执行一遍命令 特定时间执行命令 时间 含义 45 22 * * * 命令 在22点45分执行命令 八、rpm​ RPM (RedHat Package Manager)，Rethat 软件包管理工具，是LINUX这一系列操作系统里面的打包安装工具，它虽然是RatHat的标志，但理念是通用的 8.2.1 查询12rpm -qa # 功能：查询安装的所有软件rpm -qa |grep fire 8.2.2 卸载1rpm -e firefox-52.8.0-1.el6.centos.x86_64 8.2.3 安装12345rpm -ivh RPM包全名 -i=install ，安装 -v=verbose , 显示详细信息 -h=hash , 进度条 -nodeps , 不检测依赖进度 九、shell编程9.1 概述Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 9.2 shell脚本的执行方式1）echo输出内容到控制台12345678910111213141516echo [选项内容] [输出内容]echo -e 转义字符 控制字符 作 用 \\ 输出 \ 本身 \a 输出警告音 \b 退格键，也就是向左删除键 \c 取消输出行末的换行符。 和 "-n" 选项一致 \e ESCAPE 键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是 Tab 键 \v 垂直制表符 \0nnn 按照八进制ASCII码表输出字符。其中0是数字零，nnn是三位八进制数 \xhh 按照十六进制ASCII码表输出字符，其中hh是两位十六进制数 2）脚本格式 脚本是以 #!/bin/bash开头 3）第一个shell脚本需求：输出Hello world! shell 脚本 - helloworld.sh 123#!/bin/bashecho "hello world" 4）脚本的常用执行方式123456./helloworld.sh/opt/shuihu/helloworld.shsh ./helloworld.shbash ./helloworld.shsh /opt/shuihu/helloworld.shbash /opt/shuihu/helloworld.sh 9.3 shell中的变量概述： LinuxShell中变量分为”系统变量”和”用户自定义变量”，可以通过set命令查看系统变量 系统变量：$HOME $PWD $SHELL $USER等等 显示当前 shell 中所有的变量：set 9.3.1 定义变量 基本语法 定义变量: 变量=值 撤销变量：unset 变量 声明静态变量：readonly 变量 变量定义规则 等号两侧不能有空格 变量名称一般为大写 变量名称可以由字母、数字和下划线组成，但是不能以数字开头 双引号和单引号区别：双引号仅将空格脱意 ，单引号会将所有特殊字符脱意 案例 9.3.2 将命令的返回值赋给变量1234# 运行 `ls -al` 命令，并将结果返回给变量A,注意为反引号``A=`ls -al`# 等价于A=$(ls-al) 9.3.3 设置环境变量 基本语法 export 变量名=变量值 （功能描述：设置环境变量的值，提升为全局变量） source配置文件 （功能描述：让修改后的配置信息立即生效） echo $变量名 (功能描述：查询环境变量的值) 9.3.4 位置参数变量​ 基本语法： 1. `$n` : 功能描述：n 为数字, $0 代表**命令本身**，`$1-$9` 代表第一到第九个参数，十个以上的参数，需要用大括号包含，如 `${10}` 2. `$*` : 功能描述： 这个变量代表命令行中所有的参数，`$*`把所有的参数看成一个整体 3. `$@`: 功能描述： 这个变量也代表命令行中所有的参数，不过 `$@`把每一个参数区别对待 4. `$#` : 功能描述： 这个变量代表命令行中所有的参数的个数9.3.5 预定义变量基本语法： $$ : 当前进程的进程号 (PID) $! : 后台运行的最后一个进程的进程号 $? : 最后一次执行的命令的返回状态。如果这个变量的值为 0 ，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，有命令自己来决定)，则证明上一个命名执行不正确了。 9.4 运算符 基本语法： “$((运算式))” 或 “$[运算式]” expr m + n 注意：expr运算符之间要有空格 expr m - n 注意：expr 运算符之间要有空格 /,/,% *乘，除，取余 案例 计算 （2 + 3 ）* 4 12echo $[(2+3)*4]expr `expr 2 + 3` \* 4 9.5 条件判断9.5.1 判断语句1[ condition ] # 注意：condition 前后要有空格 案例 12345[ atguigu ] 返回 true[] 返回 false[ condition ] &amp;&amp; echo OK || echo notok 条件满足，执行后面的语句 9.5.2 常用条件判断 两个整数之间的比较 1234567= 字符串比较-lt 小于-le 小于等于-eq 等于-gt 大于-ge 大于等于-ne 不等于 按照文件权限进行判断 123-r 有读的权限-w 有写的权限-x 有执行的权限 按照文件类型进行判断 123-f 文件存在并且是一个常规的文件-e 文件存在-d 文件存在并是一个目录 案例 23是否大于等于22 [ 23 -get 22] student.txt是否具有写权限 [ -w student.txt] /root/install.log 目录中的文件是否存在 [ -e /root/install.log ] 9.6 流程控制9.6.1 if 判断 基本语法 1234567891011方式一：if[ 条件判断式 ];then 程序fi方式二：if[ 条件判断式 ] then 程序fi 注意事项： 1、[ 条件判断式 ] ，中括号和条件判断式之间必须有空格 案例判断输入的数是否等于123，是否等于456 ./if.sh 123 12345678910#!/bin/bashif [ $1 -eq "123" ] then echo "123" elif [ $1 -eq "456" ] then echo "456"fi 输出结果： 1123 9.6.2 case 语句 基本语法 123456789101112case $变量名 in "值1") 如果变量的值等于值1，则执行程序1 ;; "值2"） 如果变量的值等于值2，则执行程序2 ;; ...省略其他分支... *) 如果变量的值都不是以上的值，则执行此程序 ;;esac 案例 输入1，输出1；输入2，输出2 ； 输入其他，输出other; 1234567891011121314151617#!/bin/bashcase $1 in"1") echo 1;;"2") echo 2;;*) echo "other";;esac 9.6.3 for 循环 基本语法1： 1234for 变量 in 值1 值2 值3...do 程序done 案例1打印输入参数for1.sh 1234567891011#!/bin/bashfor i in "$*"do echo "$i"donefor j in "$@"do echo "$j"done 输出结果： 1234567# ./ for1.sh 1 2 3&gt;&gt;&gt;1 2 3123 基本语法2： 1234for((初始值;循环控制条件;变量变化))do 程序done 案例2 从1加到100 123456789#!/bin/bashs=0for ((i=1;i &lt;= 100; i++))do s=$[$s+$i] doneecho $s 9.6.4 while 循环 基本语法 1234while [ 条件判断式 ]do 程序done 案例从1加到100 1234567891011#!/bin/bashs=0i=1while [ $i -le 100 ]do s=$[$s + $i] i=$[$i + 1]doneecho "$s" 9.7 read读取控制台输入 基本语法 12345read (选项)(参数) 选项： -p ：指定读取值时的提示符； -t : 指定读取值时等待的时间(秒) 参数： 案例读取控制台输入的名称 123456-- 将输入的内容赋值给 `NAME`read -p "input your name " NAMEecho $NAME# 将 5 秒 内输入的内容赋值给 `NAME`read -t 5 -p "input your name" NAME 9.8 函数9.8.1 系统函数 basename基本语法 案例 123basename /opt/shuihu/for1.sh &gt;&gt;&gt; for1.sh dirname基本语法 案例 123basename /opt/shuihu/for1.sh &gt;&gt;&gt; /opt/shuihu 9.8.2 自定义函数 基本语法 1234567[ function ] funname [()]&#123; Action; [return int;]&#125;funname 注意事项 必须在调用函数地方之前，先声明函数，shell 脚本是逐行运行。不会像其它语言一样先编译 函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值 n (0-255) 案例 计算输入参数的和 12345678910#!/bin/bashfunciton sum()&#123; s=0 s=$[$1 + $2] echo "$s"&#125;read -p "Please input the number1:" n1;read -p "Please input the number2:" n2;sum $n1 $n2; 十、yum 仓库配置10.1概述YUM （全称 为 Yellow dog Updater,Modified）是一个在 Fedora和 RedHat以及CentOS中的Shell前端软件包管理器。 基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无需繁琐地一次次下载、安装。 10.2 yum 的常用命令1. 基本语法12345yum install -y httpd (功能描述：安装 httpd 并确认安装)yum list (功能描述：列出所有可用的 package 和 package 组)yum clean all (功能描述：清除所有缓冲数据)yum deplist httpd (功能描述：列出一个包所有依赖的包)yum remove httpd (功能描述：删除 httpd) 2. 案例1yum install -y tree 10.3 关联网络 yum 源在线安装 123456789101112# 首先下载网易 yum 配置文件，将该文件 移动到 /etc/yum.repos.d/ 文件夹内mv CentOS6-Base-163.repo /etc/yum.repos.d/cd /etc/yum.repos.d/# 将 CentOS-Base.repo 备份 为 CentOS-Base.repo.bakmv CentOS-Base.repo CentOS-Base.repo.bak# 将下载的网易 yum 配置文件 CentOS6-Base-163.repo 改名为 CentOS-Base.repomv CentOS6-Base-163.repo CentOS-Base.repocat CentOS-Base.repo# 清除缓存yum clean all# 安装yum makecache 制作本地yum源]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 问题]]></title>
    <url>%2F2019%2F01%2F17%2Fubuntu%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ubuntu 依赖问题sudo apt-get update # 更新 sudo apt-get -f install # 解决依赖问题 sudo dpkg -i xxx.deb # 重新安装卸载先找到软件的名称：whereis,which,find,grep 都可以 可以直接使用 dpkg 命令进行卸载，这叫做谁污染谁治理； dpkg -l |grep xxx # xxx 就是安装的软件名 找到之后，使用下面的方法进行卸载 sudo dpkg --purge xxxx rm -rf ~/.local/share/xxxx 这样的话就彻底卸载了]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2019%2F01%2F09%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[帮助命令： man 获得帮助信息 用法：man [命令或配置文件] help 获得shell内置命令的帮助信息 基础命令： pwd 查看绝对路径 mkidr 创建一个新的目录 rmdir 删除一个空的目录 touch 创建空文件 cd 切换目录 用法：（cd 绝对路径/相对路径） cd 绝对路径 cd 相对路径 cd ~ 或 cd 回到自己的家目录 cd - 回到上一次所在目录 cd.. 回到当前目录的上一级目录 cp 复制文件或目录 cp source dest 复制source文件到dest cp -r sourceFloder targetFolder 递归复制整个文件到 ls 列出目录内容 （-a/-l） ll rm 移除文件或目录 rm 删除文件 rm -rf 递归删除，可以删除包含文件的文件夹 mv 移动文件与目录或重命名 mv oldNameFile newNameFile 重命名 mv /temp/movefile/targetFolder 移动文件 cat 查看文件内容 查看文件内容，从第一行开始显示。 cat -n 显示行号，连同空白行也会有 cat -A 累出一些特殊字符，而不是空白而已 cat -b 列出行号，但针对非空白行做行号显示，空白行不标行号! cat -E 将结尾的断行字符$显示出来； cat -T 将【Tab】键以 ^|显示出来； cat -v 列出一些看不出来的特殊字符； tac 查看文件内容 查看文件内容，从最后一行开始显示，可以看出tac 是 cat 的倒着写的； more 查看文件内容 more 要查看的文件 空白键[space] 代表向下翻一页 Enter 代表向下翻一行 q 代表离开more ，不在显示该文件内容; Ctrl + F 向下滚动一屏 Ctrl + B 返回上一屏 =输出当前行的行号 :f 输出文件名和当前行的行号; less 查看文件内容 less的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less允许使用[pageup][pagedown]往回滚动； 空白键 向下翻动一页 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 /字符串 向下搜寻[字符串]的功能;n:向下查找；N:向上查找 ?字符串 向上搜寻[字符串]的功能;n:向上查找; N:向下查找 q 离开less head 查看文件内容 查看文件内容，只看头几行 tail 查看文件内容 查看文件内容，只看尾巴几行 tail -n 10 文件 tail -f 文件 实时追踪该文档的所有更新 重定向命令 ls -l &gt;文件 列表的内容写入文件a.txt中(覆盖写) ls -al &gt;&gt;文件 列表的内容追加到文件aa.txt的末尾 echo echo 要显示的内容&gt;&gt;存储内容的文件 将要显示的内容，存储到文件中 echo 变量 显示变量的值 ln软链接 ln -s[原文件][目标问价] 给原文件创建一个软链接，软链接存放在目标文件目录 history 查看所敲命令历史 vi编辑器的使用一般模式yy 复制光标当前一行 y数字y 复制一段(从第几行到第几行) p 箭头移动到目的行进行粘贴 u 撤销上一步 dd 删除光标当前行 d数字d 删除光标(含)后多少行 x 删除一个字母，相当于del X 删除一个字母，相当于Backspace yw 复制一个词 dw 删除一个词 shift + ^ 移动到行头 shift + $ 移动到行尾 1 + shift + g 移动到页头，数字 shift + g 移动到页尾 数字N + shift + g 移动到目标行编辑模式进入编辑模式 1. i 当前光标前 2. a 当前光标后 3. o 当前光标下一行 退出编辑模式 ESC指令模式 w 保存 q 退出 ! 感叹号强制执行 / 查找，/被查找词，n是查找下一个，shift + n是往上查找 ? 查找，？被查找词，n是查找上一个，shift + n是查找下一个时间日期类 date 显示当前时间 date date +%Y-%m-%d date &quot;+%Y-%m-%d %H:%M:%S&quot; date 显示非当前时间 date -d &apos;next day&apos; date -d &quot;yesterday&quot; date -d &quot;next week&quot; date -d &quot;next monday&quot; date -d &quot;1 days ago&quot; -- 显示前一天日期 date -d yesterday +%Y%m%d 显示前一天日期 date -d next day +%Y%m-%d 显示明天日期 date 设置系统时间 date -s &quot;2019-01-14 22:07:25&quot; cal 查看日历 cal cal 2019 2019年日历 cal -3 最近3个月 用户组管理命令 groupadd 新增组 groupadd 组名 groupdel 删除组 groupdel 组名 groupmod 修改组 groupmod -n 新组名 老祖名 cat/etc/group 查看创建了哪些分组 usermod 修改用户组 usermod -g 用户名 用户组 文件权限 -rw-r–r–. 1 root root 0 1月 16 21:05 duanyu.txt drwxr-xr-x. 2 root root 4096 1月 16 21:05 gaibang 第一位： - 表示文件 d 文件夹 第2-4位： 用户主的权限 r 读 w 写 x 执行 - 表示没权限 第5-7位： 用户组的权限 r 读 w 写 x 执行 - 表示没权限 第8-10位： 其他权限 r 读 w 写 x 执行 - 表示没权限 第11位： 链接数(未知) 第12位： 文件拥有者 第13位： 用户组 第14位： 创建时间 第15位： 文件名称chomod 改变权限chmod u+x demo.txt //用户 chmod g-w demo.txt //用户组 chmod o+w demo.txt //其它 chmod a+w demo.txt //所有 1：具有权限 0：没有权限 r w x 1 1 1 = 7 0 0 0 = 0 1 0 0 = 4 0 1 0 = 2 0 0 1 = 1 chmod 777 demo.txt (用户、用户组、其它都具有可读可写可执行的权限)chown 改变所有者chown [最终用户][文件或目录] chown root jiumozhi.txtchgrp 改变所属组chgrp root yijinjing.txt 同时改变拥有者 和 拥有者 的组： chown atguigu:atguigu yijinjing.txt磁盘分区类fdisk 查看分区fdisk -l 功能：查看磁盘分区详情(只有root用户)df 查看硬盘df -hmon {% aplayer "绝对是个梦" "汤宝如" "https://m10.music.126.net/20190117220544/24570c8d9a84cd0c3a470518fdc03b5b/ymusic/d52e/a4ad/4c07/8214ad8b055099de80a876fd07c82acc.mp3" "http://p1.music.126.net/ZltFcvUm0B7CYjAYUUSVHw==/61572651167679.jpg?param=130y130" "autoplay" %} 磁盘分区fdisk 查看分区 fdisk -l 查看磁盘分区详情 注意：root用户 df 查看硬盘 df -h mount/umount 挂载/卸载]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[archives]]></title>
    <url>%2Farchives%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[sitemap]]></title>
    <url>%2Fsitemap%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
